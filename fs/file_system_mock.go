package fs

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"os"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock"
)

// FileSystemMock implements FileSystem
type FileSystemMock struct {
	t minimock.Tester

	funcCreate          func(name string) (f1 File, err error)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mFileSystemMockCreate

	funcMkdir          func(name string, perm os.FileMode) (err error)
	afterMkdirCounter  uint64
	beforeMkdirCounter uint64
	MkdirMock          mFileSystemMockMkdir

	funcMkdirAll          func(path string, perm os.FileMode) (err error)
	afterMkdirAllCounter  uint64
	beforeMkdirAllCounter uint64
	MkdirAllMock          mFileSystemMockMkdirAll

	funcOpen          func(name string) (f1 File, err error)
	afterOpenCounter  uint64
	beforeOpenCounter uint64
	OpenMock          mFileSystemMockOpen

	funcOpenFile          func(name string, flag int, perm os.FileMode) (f1 File, err error)
	afterOpenFileCounter  uint64
	beforeOpenFileCounter uint64
	OpenFileMock          mFileSystemMockOpenFile

	funcRemove          func(name string) (err error)
	afterRemoveCounter  uint64
	beforeRemoveCounter uint64
	RemoveMock          mFileSystemMockRemove

	funcRemoveAll          func(path string) (err error)
	afterRemoveAllCounter  uint64
	beforeRemoveAllCounter uint64
	RemoveAllMock          mFileSystemMockRemoveAll

	funcRename          func(old string, new string) (err error)
	afterRenameCounter  uint64
	beforeRenameCounter uint64
	RenameMock          mFileSystemMockRename

	funcStat          func(name string) (f1 os.FileInfo, err error)
	afterStatCounter  uint64
	beforeStatCounter uint64
	StatMock          mFileSystemMockStat
}

// NewFileSystemMock returns a mock for FileSystem
func NewFileSystemMock(t minimock.Tester) *FileSystemMock {
	m := &FileSystemMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mFileSystemMockCreate{mock: m}
	m.CreateMock.callArgs = []*FileSystemMockCreateParams{}

	m.MkdirMock = mFileSystemMockMkdir{mock: m}
	m.MkdirMock.callArgs = []*FileSystemMockMkdirParams{}

	m.MkdirAllMock = mFileSystemMockMkdirAll{mock: m}
	m.MkdirAllMock.callArgs = []*FileSystemMockMkdirAllParams{}

	m.OpenMock = mFileSystemMockOpen{mock: m}
	m.OpenMock.callArgs = []*FileSystemMockOpenParams{}

	m.OpenFileMock = mFileSystemMockOpenFile{mock: m}
	m.OpenFileMock.callArgs = []*FileSystemMockOpenFileParams{}

	m.RemoveMock = mFileSystemMockRemove{mock: m}
	m.RemoveMock.callArgs = []*FileSystemMockRemoveParams{}

	m.RemoveAllMock = mFileSystemMockRemoveAll{mock: m}
	m.RemoveAllMock.callArgs = []*FileSystemMockRemoveAllParams{}

	m.RenameMock = mFileSystemMockRename{mock: m}
	m.RenameMock.callArgs = []*FileSystemMockRenameParams{}

	m.StatMock = mFileSystemMockStat{mock: m}
	m.StatMock.callArgs = []*FileSystemMockStatParams{}

	return m
}

type mFileSystemMockCreate struct {
	mock               *FileSystemMock
	defaultExpectation *FileSystemMockCreateExpectation
	expectations       []*FileSystemMockCreateExpectation

	callArgs []*FileSystemMockCreateParams
	mutex    sync.RWMutex
}

// FileSystemMockCreateExpectation specifies expectation struct of the FileSystem.Create
type FileSystemMockCreateExpectation struct {
	mock    *FileSystemMock
	params  *FileSystemMockCreateParams
	results *FileSystemMockCreateResults
	Counter uint64
}

// FileSystemMockCreateParams contains parameters of the FileSystem.Create
type FileSystemMockCreateParams struct {
	name string
}

// FileSystemMockCreateResults contains results of the FileSystem.Create
type FileSystemMockCreateResults struct {
	f1  File
	err error
}

// Expect sets up expected params for FileSystem.Create
func (mmCreate *mFileSystemMockCreate) Expect(name string) *mFileSystemMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("FileSystemMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &FileSystemMockCreateExpectation{}
	}

	mmCreate.defaultExpectation.params = &FileSystemMockCreateParams{name}
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// Return sets up results that will be returned by FileSystem.Create
func (mmCreate *mFileSystemMockCreate) Return(f1 File, err error) *FileSystemMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("FileSystemMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &FileSystemMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &FileSystemMockCreateResults{f1, err}
	return mmCreate.mock
}

//Set uses given function f to mock the FileSystem.Create method
func (mmCreate *mFileSystemMockCreate) Set(f func(name string) (f1 File, err error)) *FileSystemMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the FileSystem.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the FileSystem.Create method")
	}

	mmCreate.mock.funcCreate = f
	return mmCreate.mock
}

// When sets expectation for the FileSystem.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mFileSystemMockCreate) When(name string) *FileSystemMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("FileSystemMock.Create mock is already set by Set")
	}

	expectation := &FileSystemMockCreateExpectation{
		mock:   mmCreate.mock,
		params: &FileSystemMockCreateParams{name},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up FileSystem.Create return parameters for the expectation previously defined by the When method
func (e *FileSystemMockCreateExpectation) Then(f1 File, err error) *FileSystemMock {
	e.results = &FileSystemMockCreateResults{f1, err}
	return e.mock
}

// Create implements FileSystem
func (mmCreate *FileSystemMock) Create(name string) (f1 File, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	params := &FileSystemMockCreateParams{name}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.f1, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		want := mmCreate.CreateMock.defaultExpectation.params
		got := FileSystemMockCreateParams{name}
		if want != nil && !minimock.Equal(*want, got) {
			mmCreate.t.Errorf("FileSystemMock.Create got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmCreate.CreateMock.defaultExpectation.results
		if results == nil {
			mmCreate.t.Fatal("No results are set for the FileSystemMock.Create")
		}
		return (*results).f1, (*results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(name)
	}
	mmCreate.t.Fatalf("Unexpected call to FileSystemMock.Create. %v", name)
	return
}

// CreateAfterCounter returns a count of finished FileSystemMock.Create invocations
func (mmCreate *FileSystemMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of FileSystemMock.Create invocations
func (mmCreate *FileSystemMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to FileSystemMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mFileSystemMockCreate) Calls() []*FileSystemMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*FileSystemMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *FileSystemMock) MinimockCreateDone() bool {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateInspect logs each unmet expectation
func (m *FileSystemMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FileSystemMock.Create with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FileSystemMock.Create")
		} else {
			m.t.Errorf("Expected call to FileSystemMock.Create with params: %#v", *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		m.t.Error("Expected call to FileSystemMock.Create")
	}
}

type mFileSystemMockMkdir struct {
	mock               *FileSystemMock
	defaultExpectation *FileSystemMockMkdirExpectation
	expectations       []*FileSystemMockMkdirExpectation

	callArgs []*FileSystemMockMkdirParams
	mutex    sync.RWMutex
}

// FileSystemMockMkdirExpectation specifies expectation struct of the FileSystem.Mkdir
type FileSystemMockMkdirExpectation struct {
	mock    *FileSystemMock
	params  *FileSystemMockMkdirParams
	results *FileSystemMockMkdirResults
	Counter uint64
}

// FileSystemMockMkdirParams contains parameters of the FileSystem.Mkdir
type FileSystemMockMkdirParams struct {
	name string
	perm os.FileMode
}

// FileSystemMockMkdirResults contains results of the FileSystem.Mkdir
type FileSystemMockMkdirResults struct {
	err error
}

// Expect sets up expected params for FileSystem.Mkdir
func (mmMkdir *mFileSystemMockMkdir) Expect(name string, perm os.FileMode) *mFileSystemMockMkdir {
	if mmMkdir.mock.funcMkdir != nil {
		mmMkdir.mock.t.Fatalf("FileSystemMock.Mkdir mock is already set by Set")
	}

	if mmMkdir.defaultExpectation == nil {
		mmMkdir.defaultExpectation = &FileSystemMockMkdirExpectation{}
	}

	mmMkdir.defaultExpectation.params = &FileSystemMockMkdirParams{name, perm}
	for _, e := range mmMkdir.expectations {
		if minimock.Equal(e.params, mmMkdir.defaultExpectation.params) {
			mmMkdir.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmMkdir.defaultExpectation.params)
		}
	}

	return mmMkdir
}

// Return sets up results that will be returned by FileSystem.Mkdir
func (mmMkdir *mFileSystemMockMkdir) Return(err error) *FileSystemMock {
	if mmMkdir.mock.funcMkdir != nil {
		mmMkdir.mock.t.Fatalf("FileSystemMock.Mkdir mock is already set by Set")
	}

	if mmMkdir.defaultExpectation == nil {
		mmMkdir.defaultExpectation = &FileSystemMockMkdirExpectation{mock: mmMkdir.mock}
	}
	mmMkdir.defaultExpectation.results = &FileSystemMockMkdirResults{err}
	return mmMkdir.mock
}

//Set uses given function f to mock the FileSystem.Mkdir method
func (mmMkdir *mFileSystemMockMkdir) Set(f func(name string, perm os.FileMode) (err error)) *FileSystemMock {
	if mmMkdir.defaultExpectation != nil {
		mmMkdir.mock.t.Fatalf("Default expectation is already set for the FileSystem.Mkdir method")
	}

	if len(mmMkdir.expectations) > 0 {
		mmMkdir.mock.t.Fatalf("Some expectations are already set for the FileSystem.Mkdir method")
	}

	mmMkdir.mock.funcMkdir = f
	return mmMkdir.mock
}

// When sets expectation for the FileSystem.Mkdir which will trigger the result defined by the following
// Then helper
func (mmMkdir *mFileSystemMockMkdir) When(name string, perm os.FileMode) *FileSystemMockMkdirExpectation {
	if mmMkdir.mock.funcMkdir != nil {
		mmMkdir.mock.t.Fatalf("FileSystemMock.Mkdir mock is already set by Set")
	}

	expectation := &FileSystemMockMkdirExpectation{
		mock:   mmMkdir.mock,
		params: &FileSystemMockMkdirParams{name, perm},
	}
	mmMkdir.expectations = append(mmMkdir.expectations, expectation)
	return expectation
}

// Then sets up FileSystem.Mkdir return parameters for the expectation previously defined by the When method
func (e *FileSystemMockMkdirExpectation) Then(err error) *FileSystemMock {
	e.results = &FileSystemMockMkdirResults{err}
	return e.mock
}

// Mkdir implements FileSystem
func (mmMkdir *FileSystemMock) Mkdir(name string, perm os.FileMode) (err error) {
	mm_atomic.AddUint64(&mmMkdir.beforeMkdirCounter, 1)
	defer mm_atomic.AddUint64(&mmMkdir.afterMkdirCounter, 1)

	params := &FileSystemMockMkdirParams{name, perm}

	// Record call args
	mmMkdir.MkdirMock.mutex.Lock()
	mmMkdir.MkdirMock.callArgs = append(mmMkdir.MkdirMock.callArgs, params)
	mmMkdir.MkdirMock.mutex.Unlock()

	for _, e := range mmMkdir.MkdirMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmMkdir.MkdirMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMkdir.MkdirMock.defaultExpectation.Counter, 1)
		want := mmMkdir.MkdirMock.defaultExpectation.params
		got := FileSystemMockMkdirParams{name, perm}
		if want != nil && !minimock.Equal(*want, got) {
			mmMkdir.t.Errorf("FileSystemMock.Mkdir got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmMkdir.MkdirMock.defaultExpectation.results
		if results == nil {
			mmMkdir.t.Fatal("No results are set for the FileSystemMock.Mkdir")
		}
		return (*results).err
	}
	if mmMkdir.funcMkdir != nil {
		return mmMkdir.funcMkdir(name, perm)
	}
	mmMkdir.t.Fatalf("Unexpected call to FileSystemMock.Mkdir. %v %v", name, perm)
	return
}

// MkdirAfterCounter returns a count of finished FileSystemMock.Mkdir invocations
func (mmMkdir *FileSystemMock) MkdirAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMkdir.afterMkdirCounter)
}

// MkdirBeforeCounter returns a count of FileSystemMock.Mkdir invocations
func (mmMkdir *FileSystemMock) MkdirBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMkdir.beforeMkdirCounter)
}

// Calls returns a list of arguments used in each call to FileSystemMock.Mkdir.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmMkdir *mFileSystemMockMkdir) Calls() []*FileSystemMockMkdirParams {
	mmMkdir.mutex.RLock()

	argCopy := make([]*FileSystemMockMkdirParams, len(mmMkdir.callArgs))
	copy(argCopy, mmMkdir.callArgs)

	mmMkdir.mutex.RUnlock()

	return argCopy
}

// MinimockMkdirDone returns true if the count of the Mkdir invocations corresponds
// the number of defined expectations
func (m *FileSystemMock) MinimockMkdirDone() bool {
	for _, e := range m.MkdirMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MkdirMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMkdirCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMkdir != nil && mm_atomic.LoadUint64(&m.afterMkdirCounter) < 1 {
		return false
	}
	return true
}

// MinimockMkdirInspect logs each unmet expectation
func (m *FileSystemMock) MinimockMkdirInspect() {
	for _, e := range m.MkdirMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FileSystemMock.Mkdir with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MkdirMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMkdirCounter) < 1 {
		if m.MkdirMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FileSystemMock.Mkdir")
		} else {
			m.t.Errorf("Expected call to FileSystemMock.Mkdir with params: %#v", *m.MkdirMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMkdir != nil && mm_atomic.LoadUint64(&m.afterMkdirCounter) < 1 {
		m.t.Error("Expected call to FileSystemMock.Mkdir")
	}
}

type mFileSystemMockMkdirAll struct {
	mock               *FileSystemMock
	defaultExpectation *FileSystemMockMkdirAllExpectation
	expectations       []*FileSystemMockMkdirAllExpectation

	callArgs []*FileSystemMockMkdirAllParams
	mutex    sync.RWMutex
}

// FileSystemMockMkdirAllExpectation specifies expectation struct of the FileSystem.MkdirAll
type FileSystemMockMkdirAllExpectation struct {
	mock    *FileSystemMock
	params  *FileSystemMockMkdirAllParams
	results *FileSystemMockMkdirAllResults
	Counter uint64
}

// FileSystemMockMkdirAllParams contains parameters of the FileSystem.MkdirAll
type FileSystemMockMkdirAllParams struct {
	path string
	perm os.FileMode
}

// FileSystemMockMkdirAllResults contains results of the FileSystem.MkdirAll
type FileSystemMockMkdirAllResults struct {
	err error
}

// Expect sets up expected params for FileSystem.MkdirAll
func (mmMkdirAll *mFileSystemMockMkdirAll) Expect(path string, perm os.FileMode) *mFileSystemMockMkdirAll {
	if mmMkdirAll.mock.funcMkdirAll != nil {
		mmMkdirAll.mock.t.Fatalf("FileSystemMock.MkdirAll mock is already set by Set")
	}

	if mmMkdirAll.defaultExpectation == nil {
		mmMkdirAll.defaultExpectation = &FileSystemMockMkdirAllExpectation{}
	}

	mmMkdirAll.defaultExpectation.params = &FileSystemMockMkdirAllParams{path, perm}
	for _, e := range mmMkdirAll.expectations {
		if minimock.Equal(e.params, mmMkdirAll.defaultExpectation.params) {
			mmMkdirAll.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmMkdirAll.defaultExpectation.params)
		}
	}

	return mmMkdirAll
}

// Return sets up results that will be returned by FileSystem.MkdirAll
func (mmMkdirAll *mFileSystemMockMkdirAll) Return(err error) *FileSystemMock {
	if mmMkdirAll.mock.funcMkdirAll != nil {
		mmMkdirAll.mock.t.Fatalf("FileSystemMock.MkdirAll mock is already set by Set")
	}

	if mmMkdirAll.defaultExpectation == nil {
		mmMkdirAll.defaultExpectation = &FileSystemMockMkdirAllExpectation{mock: mmMkdirAll.mock}
	}
	mmMkdirAll.defaultExpectation.results = &FileSystemMockMkdirAllResults{err}
	return mmMkdirAll.mock
}

//Set uses given function f to mock the FileSystem.MkdirAll method
func (mmMkdirAll *mFileSystemMockMkdirAll) Set(f func(path string, perm os.FileMode) (err error)) *FileSystemMock {
	if mmMkdirAll.defaultExpectation != nil {
		mmMkdirAll.mock.t.Fatalf("Default expectation is already set for the FileSystem.MkdirAll method")
	}

	if len(mmMkdirAll.expectations) > 0 {
		mmMkdirAll.mock.t.Fatalf("Some expectations are already set for the FileSystem.MkdirAll method")
	}

	mmMkdirAll.mock.funcMkdirAll = f
	return mmMkdirAll.mock
}

// When sets expectation for the FileSystem.MkdirAll which will trigger the result defined by the following
// Then helper
func (mmMkdirAll *mFileSystemMockMkdirAll) When(path string, perm os.FileMode) *FileSystemMockMkdirAllExpectation {
	if mmMkdirAll.mock.funcMkdirAll != nil {
		mmMkdirAll.mock.t.Fatalf("FileSystemMock.MkdirAll mock is already set by Set")
	}

	expectation := &FileSystemMockMkdirAllExpectation{
		mock:   mmMkdirAll.mock,
		params: &FileSystemMockMkdirAllParams{path, perm},
	}
	mmMkdirAll.expectations = append(mmMkdirAll.expectations, expectation)
	return expectation
}

// Then sets up FileSystem.MkdirAll return parameters for the expectation previously defined by the When method
func (e *FileSystemMockMkdirAllExpectation) Then(err error) *FileSystemMock {
	e.results = &FileSystemMockMkdirAllResults{err}
	return e.mock
}

// MkdirAll implements FileSystem
func (mmMkdirAll *FileSystemMock) MkdirAll(path string, perm os.FileMode) (err error) {
	mm_atomic.AddUint64(&mmMkdirAll.beforeMkdirAllCounter, 1)
	defer mm_atomic.AddUint64(&mmMkdirAll.afterMkdirAllCounter, 1)

	params := &FileSystemMockMkdirAllParams{path, perm}

	// Record call args
	mmMkdirAll.MkdirAllMock.mutex.Lock()
	mmMkdirAll.MkdirAllMock.callArgs = append(mmMkdirAll.MkdirAllMock.callArgs, params)
	mmMkdirAll.MkdirAllMock.mutex.Unlock()

	for _, e := range mmMkdirAll.MkdirAllMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmMkdirAll.MkdirAllMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMkdirAll.MkdirAllMock.defaultExpectation.Counter, 1)
		want := mmMkdirAll.MkdirAllMock.defaultExpectation.params
		got := FileSystemMockMkdirAllParams{path, perm}
		if want != nil && !minimock.Equal(*want, got) {
			mmMkdirAll.t.Errorf("FileSystemMock.MkdirAll got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmMkdirAll.MkdirAllMock.defaultExpectation.results
		if results == nil {
			mmMkdirAll.t.Fatal("No results are set for the FileSystemMock.MkdirAll")
		}
		return (*results).err
	}
	if mmMkdirAll.funcMkdirAll != nil {
		return mmMkdirAll.funcMkdirAll(path, perm)
	}
	mmMkdirAll.t.Fatalf("Unexpected call to FileSystemMock.MkdirAll. %v %v", path, perm)
	return
}

// MkdirAllAfterCounter returns a count of finished FileSystemMock.MkdirAll invocations
func (mmMkdirAll *FileSystemMock) MkdirAllAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMkdirAll.afterMkdirAllCounter)
}

// MkdirAllBeforeCounter returns a count of FileSystemMock.MkdirAll invocations
func (mmMkdirAll *FileSystemMock) MkdirAllBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMkdirAll.beforeMkdirAllCounter)
}

// Calls returns a list of arguments used in each call to FileSystemMock.MkdirAll.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmMkdirAll *mFileSystemMockMkdirAll) Calls() []*FileSystemMockMkdirAllParams {
	mmMkdirAll.mutex.RLock()

	argCopy := make([]*FileSystemMockMkdirAllParams, len(mmMkdirAll.callArgs))
	copy(argCopy, mmMkdirAll.callArgs)

	mmMkdirAll.mutex.RUnlock()

	return argCopy
}

// MinimockMkdirAllDone returns true if the count of the MkdirAll invocations corresponds
// the number of defined expectations
func (m *FileSystemMock) MinimockMkdirAllDone() bool {
	for _, e := range m.MkdirAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MkdirAllMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMkdirAllCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMkdirAll != nil && mm_atomic.LoadUint64(&m.afterMkdirAllCounter) < 1 {
		return false
	}
	return true
}

// MinimockMkdirAllInspect logs each unmet expectation
func (m *FileSystemMock) MinimockMkdirAllInspect() {
	for _, e := range m.MkdirAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FileSystemMock.MkdirAll with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MkdirAllMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMkdirAllCounter) < 1 {
		if m.MkdirAllMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FileSystemMock.MkdirAll")
		} else {
			m.t.Errorf("Expected call to FileSystemMock.MkdirAll with params: %#v", *m.MkdirAllMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMkdirAll != nil && mm_atomic.LoadUint64(&m.afterMkdirAllCounter) < 1 {
		m.t.Error("Expected call to FileSystemMock.MkdirAll")
	}
}

type mFileSystemMockOpen struct {
	mock               *FileSystemMock
	defaultExpectation *FileSystemMockOpenExpectation
	expectations       []*FileSystemMockOpenExpectation

	callArgs []*FileSystemMockOpenParams
	mutex    sync.RWMutex
}

// FileSystemMockOpenExpectation specifies expectation struct of the FileSystem.Open
type FileSystemMockOpenExpectation struct {
	mock    *FileSystemMock
	params  *FileSystemMockOpenParams
	results *FileSystemMockOpenResults
	Counter uint64
}

// FileSystemMockOpenParams contains parameters of the FileSystem.Open
type FileSystemMockOpenParams struct {
	name string
}

// FileSystemMockOpenResults contains results of the FileSystem.Open
type FileSystemMockOpenResults struct {
	f1  File
	err error
}

// Expect sets up expected params for FileSystem.Open
func (mmOpen *mFileSystemMockOpen) Expect(name string) *mFileSystemMockOpen {
	if mmOpen.mock.funcOpen != nil {
		mmOpen.mock.t.Fatalf("FileSystemMock.Open mock is already set by Set")
	}

	if mmOpen.defaultExpectation == nil {
		mmOpen.defaultExpectation = &FileSystemMockOpenExpectation{}
	}

	mmOpen.defaultExpectation.params = &FileSystemMockOpenParams{name}
	for _, e := range mmOpen.expectations {
		if minimock.Equal(e.params, mmOpen.defaultExpectation.params) {
			mmOpen.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmOpen.defaultExpectation.params)
		}
	}

	return mmOpen
}

// Return sets up results that will be returned by FileSystem.Open
func (mmOpen *mFileSystemMockOpen) Return(f1 File, err error) *FileSystemMock {
	if mmOpen.mock.funcOpen != nil {
		mmOpen.mock.t.Fatalf("FileSystemMock.Open mock is already set by Set")
	}

	if mmOpen.defaultExpectation == nil {
		mmOpen.defaultExpectation = &FileSystemMockOpenExpectation{mock: mmOpen.mock}
	}
	mmOpen.defaultExpectation.results = &FileSystemMockOpenResults{f1, err}
	return mmOpen.mock
}

//Set uses given function f to mock the FileSystem.Open method
func (mmOpen *mFileSystemMockOpen) Set(f func(name string) (f1 File, err error)) *FileSystemMock {
	if mmOpen.defaultExpectation != nil {
		mmOpen.mock.t.Fatalf("Default expectation is already set for the FileSystem.Open method")
	}

	if len(mmOpen.expectations) > 0 {
		mmOpen.mock.t.Fatalf("Some expectations are already set for the FileSystem.Open method")
	}

	mmOpen.mock.funcOpen = f
	return mmOpen.mock
}

// When sets expectation for the FileSystem.Open which will trigger the result defined by the following
// Then helper
func (mmOpen *mFileSystemMockOpen) When(name string) *FileSystemMockOpenExpectation {
	if mmOpen.mock.funcOpen != nil {
		mmOpen.mock.t.Fatalf("FileSystemMock.Open mock is already set by Set")
	}

	expectation := &FileSystemMockOpenExpectation{
		mock:   mmOpen.mock,
		params: &FileSystemMockOpenParams{name},
	}
	mmOpen.expectations = append(mmOpen.expectations, expectation)
	return expectation
}

// Then sets up FileSystem.Open return parameters for the expectation previously defined by the When method
func (e *FileSystemMockOpenExpectation) Then(f1 File, err error) *FileSystemMock {
	e.results = &FileSystemMockOpenResults{f1, err}
	return e.mock
}

// Open implements FileSystem
func (mmOpen *FileSystemMock) Open(name string) (f1 File, err error) {
	mm_atomic.AddUint64(&mmOpen.beforeOpenCounter, 1)
	defer mm_atomic.AddUint64(&mmOpen.afterOpenCounter, 1)

	params := &FileSystemMockOpenParams{name}

	// Record call args
	mmOpen.OpenMock.mutex.Lock()
	mmOpen.OpenMock.callArgs = append(mmOpen.OpenMock.callArgs, params)
	mmOpen.OpenMock.mutex.Unlock()

	for _, e := range mmOpen.OpenMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.f1, e.results.err
		}
	}

	if mmOpen.OpenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOpen.OpenMock.defaultExpectation.Counter, 1)
		want := mmOpen.OpenMock.defaultExpectation.params
		got := FileSystemMockOpenParams{name}
		if want != nil && !minimock.Equal(*want, got) {
			mmOpen.t.Errorf("FileSystemMock.Open got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmOpen.OpenMock.defaultExpectation.results
		if results == nil {
			mmOpen.t.Fatal("No results are set for the FileSystemMock.Open")
		}
		return (*results).f1, (*results).err
	}
	if mmOpen.funcOpen != nil {
		return mmOpen.funcOpen(name)
	}
	mmOpen.t.Fatalf("Unexpected call to FileSystemMock.Open. %v", name)
	return
}

// OpenAfterCounter returns a count of finished FileSystemMock.Open invocations
func (mmOpen *FileSystemMock) OpenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOpen.afterOpenCounter)
}

// OpenBeforeCounter returns a count of FileSystemMock.Open invocations
func (mmOpen *FileSystemMock) OpenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOpen.beforeOpenCounter)
}

// Calls returns a list of arguments used in each call to FileSystemMock.Open.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmOpen *mFileSystemMockOpen) Calls() []*FileSystemMockOpenParams {
	mmOpen.mutex.RLock()

	argCopy := make([]*FileSystemMockOpenParams, len(mmOpen.callArgs))
	copy(argCopy, mmOpen.callArgs)

	mmOpen.mutex.RUnlock()

	return argCopy
}

// MinimockOpenDone returns true if the count of the Open invocations corresponds
// the number of defined expectations
func (m *FileSystemMock) MinimockOpenDone() bool {
	for _, e := range m.OpenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OpenMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOpenCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOpen != nil && mm_atomic.LoadUint64(&m.afterOpenCounter) < 1 {
		return false
	}
	return true
}

// MinimockOpenInspect logs each unmet expectation
func (m *FileSystemMock) MinimockOpenInspect() {
	for _, e := range m.OpenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FileSystemMock.Open with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OpenMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOpenCounter) < 1 {
		if m.OpenMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FileSystemMock.Open")
		} else {
			m.t.Errorf("Expected call to FileSystemMock.Open with params: %#v", *m.OpenMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOpen != nil && mm_atomic.LoadUint64(&m.afterOpenCounter) < 1 {
		m.t.Error("Expected call to FileSystemMock.Open")
	}
}

type mFileSystemMockOpenFile struct {
	mock               *FileSystemMock
	defaultExpectation *FileSystemMockOpenFileExpectation
	expectations       []*FileSystemMockOpenFileExpectation

	callArgs []*FileSystemMockOpenFileParams
	mutex    sync.RWMutex
}

// FileSystemMockOpenFileExpectation specifies expectation struct of the FileSystem.OpenFile
type FileSystemMockOpenFileExpectation struct {
	mock    *FileSystemMock
	params  *FileSystemMockOpenFileParams
	results *FileSystemMockOpenFileResults
	Counter uint64
}

// FileSystemMockOpenFileParams contains parameters of the FileSystem.OpenFile
type FileSystemMockOpenFileParams struct {
	name string
	flag int
	perm os.FileMode
}

// FileSystemMockOpenFileResults contains results of the FileSystem.OpenFile
type FileSystemMockOpenFileResults struct {
	f1  File
	err error
}

// Expect sets up expected params for FileSystem.OpenFile
func (mmOpenFile *mFileSystemMockOpenFile) Expect(name string, flag int, perm os.FileMode) *mFileSystemMockOpenFile {
	if mmOpenFile.mock.funcOpenFile != nil {
		mmOpenFile.mock.t.Fatalf("FileSystemMock.OpenFile mock is already set by Set")
	}

	if mmOpenFile.defaultExpectation == nil {
		mmOpenFile.defaultExpectation = &FileSystemMockOpenFileExpectation{}
	}

	mmOpenFile.defaultExpectation.params = &FileSystemMockOpenFileParams{name, flag, perm}
	for _, e := range mmOpenFile.expectations {
		if minimock.Equal(e.params, mmOpenFile.defaultExpectation.params) {
			mmOpenFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmOpenFile.defaultExpectation.params)
		}
	}

	return mmOpenFile
}

// Return sets up results that will be returned by FileSystem.OpenFile
func (mmOpenFile *mFileSystemMockOpenFile) Return(f1 File, err error) *FileSystemMock {
	if mmOpenFile.mock.funcOpenFile != nil {
		mmOpenFile.mock.t.Fatalf("FileSystemMock.OpenFile mock is already set by Set")
	}

	if mmOpenFile.defaultExpectation == nil {
		mmOpenFile.defaultExpectation = &FileSystemMockOpenFileExpectation{mock: mmOpenFile.mock}
	}
	mmOpenFile.defaultExpectation.results = &FileSystemMockOpenFileResults{f1, err}
	return mmOpenFile.mock
}

//Set uses given function f to mock the FileSystem.OpenFile method
func (mmOpenFile *mFileSystemMockOpenFile) Set(f func(name string, flag int, perm os.FileMode) (f1 File, err error)) *FileSystemMock {
	if mmOpenFile.defaultExpectation != nil {
		mmOpenFile.mock.t.Fatalf("Default expectation is already set for the FileSystem.OpenFile method")
	}

	if len(mmOpenFile.expectations) > 0 {
		mmOpenFile.mock.t.Fatalf("Some expectations are already set for the FileSystem.OpenFile method")
	}

	mmOpenFile.mock.funcOpenFile = f
	return mmOpenFile.mock
}

// When sets expectation for the FileSystem.OpenFile which will trigger the result defined by the following
// Then helper
func (mmOpenFile *mFileSystemMockOpenFile) When(name string, flag int, perm os.FileMode) *FileSystemMockOpenFileExpectation {
	if mmOpenFile.mock.funcOpenFile != nil {
		mmOpenFile.mock.t.Fatalf("FileSystemMock.OpenFile mock is already set by Set")
	}

	expectation := &FileSystemMockOpenFileExpectation{
		mock:   mmOpenFile.mock,
		params: &FileSystemMockOpenFileParams{name, flag, perm},
	}
	mmOpenFile.expectations = append(mmOpenFile.expectations, expectation)
	return expectation
}

// Then sets up FileSystem.OpenFile return parameters for the expectation previously defined by the When method
func (e *FileSystemMockOpenFileExpectation) Then(f1 File, err error) *FileSystemMock {
	e.results = &FileSystemMockOpenFileResults{f1, err}
	return e.mock
}

// OpenFile implements FileSystem
func (mmOpenFile *FileSystemMock) OpenFile(name string, flag int, perm os.FileMode) (f1 File, err error) {
	mm_atomic.AddUint64(&mmOpenFile.beforeOpenFileCounter, 1)
	defer mm_atomic.AddUint64(&mmOpenFile.afterOpenFileCounter, 1)

	params := &FileSystemMockOpenFileParams{name, flag, perm}

	// Record call args
	mmOpenFile.OpenFileMock.mutex.Lock()
	mmOpenFile.OpenFileMock.callArgs = append(mmOpenFile.OpenFileMock.callArgs, params)
	mmOpenFile.OpenFileMock.mutex.Unlock()

	for _, e := range mmOpenFile.OpenFileMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.f1, e.results.err
		}
	}

	if mmOpenFile.OpenFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOpenFile.OpenFileMock.defaultExpectation.Counter, 1)
		want := mmOpenFile.OpenFileMock.defaultExpectation.params
		got := FileSystemMockOpenFileParams{name, flag, perm}
		if want != nil && !minimock.Equal(*want, got) {
			mmOpenFile.t.Errorf("FileSystemMock.OpenFile got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmOpenFile.OpenFileMock.defaultExpectation.results
		if results == nil {
			mmOpenFile.t.Fatal("No results are set for the FileSystemMock.OpenFile")
		}
		return (*results).f1, (*results).err
	}
	if mmOpenFile.funcOpenFile != nil {
		return mmOpenFile.funcOpenFile(name, flag, perm)
	}
	mmOpenFile.t.Fatalf("Unexpected call to FileSystemMock.OpenFile. %v %v %v", name, flag, perm)
	return
}

// OpenFileAfterCounter returns a count of finished FileSystemMock.OpenFile invocations
func (mmOpenFile *FileSystemMock) OpenFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOpenFile.afterOpenFileCounter)
}

// OpenFileBeforeCounter returns a count of FileSystemMock.OpenFile invocations
func (mmOpenFile *FileSystemMock) OpenFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOpenFile.beforeOpenFileCounter)
}

// Calls returns a list of arguments used in each call to FileSystemMock.OpenFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmOpenFile *mFileSystemMockOpenFile) Calls() []*FileSystemMockOpenFileParams {
	mmOpenFile.mutex.RLock()

	argCopy := make([]*FileSystemMockOpenFileParams, len(mmOpenFile.callArgs))
	copy(argCopy, mmOpenFile.callArgs)

	mmOpenFile.mutex.RUnlock()

	return argCopy
}

// MinimockOpenFileDone returns true if the count of the OpenFile invocations corresponds
// the number of defined expectations
func (m *FileSystemMock) MinimockOpenFileDone() bool {
	for _, e := range m.OpenFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OpenFileMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOpenFileCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOpenFile != nil && mm_atomic.LoadUint64(&m.afterOpenFileCounter) < 1 {
		return false
	}
	return true
}

// MinimockOpenFileInspect logs each unmet expectation
func (m *FileSystemMock) MinimockOpenFileInspect() {
	for _, e := range m.OpenFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FileSystemMock.OpenFile with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OpenFileMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOpenFileCounter) < 1 {
		if m.OpenFileMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FileSystemMock.OpenFile")
		} else {
			m.t.Errorf("Expected call to FileSystemMock.OpenFile with params: %#v", *m.OpenFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOpenFile != nil && mm_atomic.LoadUint64(&m.afterOpenFileCounter) < 1 {
		m.t.Error("Expected call to FileSystemMock.OpenFile")
	}
}

type mFileSystemMockRemove struct {
	mock               *FileSystemMock
	defaultExpectation *FileSystemMockRemoveExpectation
	expectations       []*FileSystemMockRemoveExpectation

	callArgs []*FileSystemMockRemoveParams
	mutex    sync.RWMutex
}

// FileSystemMockRemoveExpectation specifies expectation struct of the FileSystem.Remove
type FileSystemMockRemoveExpectation struct {
	mock    *FileSystemMock
	params  *FileSystemMockRemoveParams
	results *FileSystemMockRemoveResults
	Counter uint64
}

// FileSystemMockRemoveParams contains parameters of the FileSystem.Remove
type FileSystemMockRemoveParams struct {
	name string
}

// FileSystemMockRemoveResults contains results of the FileSystem.Remove
type FileSystemMockRemoveResults struct {
	err error
}

// Expect sets up expected params for FileSystem.Remove
func (mmRemove *mFileSystemMockRemove) Expect(name string) *mFileSystemMockRemove {
	if mmRemove.mock.funcRemove != nil {
		mmRemove.mock.t.Fatalf("FileSystemMock.Remove mock is already set by Set")
	}

	if mmRemove.defaultExpectation == nil {
		mmRemove.defaultExpectation = &FileSystemMockRemoveExpectation{}
	}

	mmRemove.defaultExpectation.params = &FileSystemMockRemoveParams{name}
	for _, e := range mmRemove.expectations {
		if minimock.Equal(e.params, mmRemove.defaultExpectation.params) {
			mmRemove.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRemove.defaultExpectation.params)
		}
	}

	return mmRemove
}

// Return sets up results that will be returned by FileSystem.Remove
func (mmRemove *mFileSystemMockRemove) Return(err error) *FileSystemMock {
	if mmRemove.mock.funcRemove != nil {
		mmRemove.mock.t.Fatalf("FileSystemMock.Remove mock is already set by Set")
	}

	if mmRemove.defaultExpectation == nil {
		mmRemove.defaultExpectation = &FileSystemMockRemoveExpectation{mock: mmRemove.mock}
	}
	mmRemove.defaultExpectation.results = &FileSystemMockRemoveResults{err}
	return mmRemove.mock
}

//Set uses given function f to mock the FileSystem.Remove method
func (mmRemove *mFileSystemMockRemove) Set(f func(name string) (err error)) *FileSystemMock {
	if mmRemove.defaultExpectation != nil {
		mmRemove.mock.t.Fatalf("Default expectation is already set for the FileSystem.Remove method")
	}

	if len(mmRemove.expectations) > 0 {
		mmRemove.mock.t.Fatalf("Some expectations are already set for the FileSystem.Remove method")
	}

	mmRemove.mock.funcRemove = f
	return mmRemove.mock
}

// When sets expectation for the FileSystem.Remove which will trigger the result defined by the following
// Then helper
func (mmRemove *mFileSystemMockRemove) When(name string) *FileSystemMockRemoveExpectation {
	if mmRemove.mock.funcRemove != nil {
		mmRemove.mock.t.Fatalf("FileSystemMock.Remove mock is already set by Set")
	}

	expectation := &FileSystemMockRemoveExpectation{
		mock:   mmRemove.mock,
		params: &FileSystemMockRemoveParams{name},
	}
	mmRemove.expectations = append(mmRemove.expectations, expectation)
	return expectation
}

// Then sets up FileSystem.Remove return parameters for the expectation previously defined by the When method
func (e *FileSystemMockRemoveExpectation) Then(err error) *FileSystemMock {
	e.results = &FileSystemMockRemoveResults{err}
	return e.mock
}

// Remove implements FileSystem
func (mmRemove *FileSystemMock) Remove(name string) (err error) {
	mm_atomic.AddUint64(&mmRemove.beforeRemoveCounter, 1)
	defer mm_atomic.AddUint64(&mmRemove.afterRemoveCounter, 1)

	params := &FileSystemMockRemoveParams{name}

	// Record call args
	mmRemove.RemoveMock.mutex.Lock()
	mmRemove.RemoveMock.callArgs = append(mmRemove.RemoveMock.callArgs, params)
	mmRemove.RemoveMock.mutex.Unlock()

	for _, e := range mmRemove.RemoveMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRemove.RemoveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemove.RemoveMock.defaultExpectation.Counter, 1)
		want := mmRemove.RemoveMock.defaultExpectation.params
		got := FileSystemMockRemoveParams{name}
		if want != nil && !minimock.Equal(*want, got) {
			mmRemove.t.Errorf("FileSystemMock.Remove got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmRemove.RemoveMock.defaultExpectation.results
		if results == nil {
			mmRemove.t.Fatal("No results are set for the FileSystemMock.Remove")
		}
		return (*results).err
	}
	if mmRemove.funcRemove != nil {
		return mmRemove.funcRemove(name)
	}
	mmRemove.t.Fatalf("Unexpected call to FileSystemMock.Remove. %v", name)
	return
}

// RemoveAfterCounter returns a count of finished FileSystemMock.Remove invocations
func (mmRemove *FileSystemMock) RemoveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemove.afterRemoveCounter)
}

// RemoveBeforeCounter returns a count of FileSystemMock.Remove invocations
func (mmRemove *FileSystemMock) RemoveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemove.beforeRemoveCounter)
}

// Calls returns a list of arguments used in each call to FileSystemMock.Remove.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRemove *mFileSystemMockRemove) Calls() []*FileSystemMockRemoveParams {
	mmRemove.mutex.RLock()

	argCopy := make([]*FileSystemMockRemoveParams, len(mmRemove.callArgs))
	copy(argCopy, mmRemove.callArgs)

	mmRemove.mutex.RUnlock()

	return argCopy
}

// MinimockRemoveDone returns true if the count of the Remove invocations corresponds
// the number of defined expectations
func (m *FileSystemMock) MinimockRemoveDone() bool {
	for _, e := range m.RemoveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRemoveCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemove != nil && mm_atomic.LoadUint64(&m.afterRemoveCounter) < 1 {
		return false
	}
	return true
}

// MinimockRemoveInspect logs each unmet expectation
func (m *FileSystemMock) MinimockRemoveInspect() {
	for _, e := range m.RemoveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FileSystemMock.Remove with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRemoveCounter) < 1 {
		if m.RemoveMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FileSystemMock.Remove")
		} else {
			m.t.Errorf("Expected call to FileSystemMock.Remove with params: %#v", *m.RemoveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemove != nil && mm_atomic.LoadUint64(&m.afterRemoveCounter) < 1 {
		m.t.Error("Expected call to FileSystemMock.Remove")
	}
}

type mFileSystemMockRemoveAll struct {
	mock               *FileSystemMock
	defaultExpectation *FileSystemMockRemoveAllExpectation
	expectations       []*FileSystemMockRemoveAllExpectation

	callArgs []*FileSystemMockRemoveAllParams
	mutex    sync.RWMutex
}

// FileSystemMockRemoveAllExpectation specifies expectation struct of the FileSystem.RemoveAll
type FileSystemMockRemoveAllExpectation struct {
	mock    *FileSystemMock
	params  *FileSystemMockRemoveAllParams
	results *FileSystemMockRemoveAllResults
	Counter uint64
}

// FileSystemMockRemoveAllParams contains parameters of the FileSystem.RemoveAll
type FileSystemMockRemoveAllParams struct {
	path string
}

// FileSystemMockRemoveAllResults contains results of the FileSystem.RemoveAll
type FileSystemMockRemoveAllResults struct {
	err error
}

// Expect sets up expected params for FileSystem.RemoveAll
func (mmRemoveAll *mFileSystemMockRemoveAll) Expect(path string) *mFileSystemMockRemoveAll {
	if mmRemoveAll.mock.funcRemoveAll != nil {
		mmRemoveAll.mock.t.Fatalf("FileSystemMock.RemoveAll mock is already set by Set")
	}

	if mmRemoveAll.defaultExpectation == nil {
		mmRemoveAll.defaultExpectation = &FileSystemMockRemoveAllExpectation{}
	}

	mmRemoveAll.defaultExpectation.params = &FileSystemMockRemoveAllParams{path}
	for _, e := range mmRemoveAll.expectations {
		if minimock.Equal(e.params, mmRemoveAll.defaultExpectation.params) {
			mmRemoveAll.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRemoveAll.defaultExpectation.params)
		}
	}

	return mmRemoveAll
}

// Return sets up results that will be returned by FileSystem.RemoveAll
func (mmRemoveAll *mFileSystemMockRemoveAll) Return(err error) *FileSystemMock {
	if mmRemoveAll.mock.funcRemoveAll != nil {
		mmRemoveAll.mock.t.Fatalf("FileSystemMock.RemoveAll mock is already set by Set")
	}

	if mmRemoveAll.defaultExpectation == nil {
		mmRemoveAll.defaultExpectation = &FileSystemMockRemoveAllExpectation{mock: mmRemoveAll.mock}
	}
	mmRemoveAll.defaultExpectation.results = &FileSystemMockRemoveAllResults{err}
	return mmRemoveAll.mock
}

//Set uses given function f to mock the FileSystem.RemoveAll method
func (mmRemoveAll *mFileSystemMockRemoveAll) Set(f func(path string) (err error)) *FileSystemMock {
	if mmRemoveAll.defaultExpectation != nil {
		mmRemoveAll.mock.t.Fatalf("Default expectation is already set for the FileSystem.RemoveAll method")
	}

	if len(mmRemoveAll.expectations) > 0 {
		mmRemoveAll.mock.t.Fatalf("Some expectations are already set for the FileSystem.RemoveAll method")
	}

	mmRemoveAll.mock.funcRemoveAll = f
	return mmRemoveAll.mock
}

// When sets expectation for the FileSystem.RemoveAll which will trigger the result defined by the following
// Then helper
func (mmRemoveAll *mFileSystemMockRemoveAll) When(path string) *FileSystemMockRemoveAllExpectation {
	if mmRemoveAll.mock.funcRemoveAll != nil {
		mmRemoveAll.mock.t.Fatalf("FileSystemMock.RemoveAll mock is already set by Set")
	}

	expectation := &FileSystemMockRemoveAllExpectation{
		mock:   mmRemoveAll.mock,
		params: &FileSystemMockRemoveAllParams{path},
	}
	mmRemoveAll.expectations = append(mmRemoveAll.expectations, expectation)
	return expectation
}

// Then sets up FileSystem.RemoveAll return parameters for the expectation previously defined by the When method
func (e *FileSystemMockRemoveAllExpectation) Then(err error) *FileSystemMock {
	e.results = &FileSystemMockRemoveAllResults{err}
	return e.mock
}

// RemoveAll implements FileSystem
func (mmRemoveAll *FileSystemMock) RemoveAll(path string) (err error) {
	mm_atomic.AddUint64(&mmRemoveAll.beforeRemoveAllCounter, 1)
	defer mm_atomic.AddUint64(&mmRemoveAll.afterRemoveAllCounter, 1)

	params := &FileSystemMockRemoveAllParams{path}

	// Record call args
	mmRemoveAll.RemoveAllMock.mutex.Lock()
	mmRemoveAll.RemoveAllMock.callArgs = append(mmRemoveAll.RemoveAllMock.callArgs, params)
	mmRemoveAll.RemoveAllMock.mutex.Unlock()

	for _, e := range mmRemoveAll.RemoveAllMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRemoveAll.RemoveAllMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemoveAll.RemoveAllMock.defaultExpectation.Counter, 1)
		want := mmRemoveAll.RemoveAllMock.defaultExpectation.params
		got := FileSystemMockRemoveAllParams{path}
		if want != nil && !minimock.Equal(*want, got) {
			mmRemoveAll.t.Errorf("FileSystemMock.RemoveAll got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmRemoveAll.RemoveAllMock.defaultExpectation.results
		if results == nil {
			mmRemoveAll.t.Fatal("No results are set for the FileSystemMock.RemoveAll")
		}
		return (*results).err
	}
	if mmRemoveAll.funcRemoveAll != nil {
		return mmRemoveAll.funcRemoveAll(path)
	}
	mmRemoveAll.t.Fatalf("Unexpected call to FileSystemMock.RemoveAll. %v", path)
	return
}

// RemoveAllAfterCounter returns a count of finished FileSystemMock.RemoveAll invocations
func (mmRemoveAll *FileSystemMock) RemoveAllAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveAll.afterRemoveAllCounter)
}

// RemoveAllBeforeCounter returns a count of FileSystemMock.RemoveAll invocations
func (mmRemoveAll *FileSystemMock) RemoveAllBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveAll.beforeRemoveAllCounter)
}

// Calls returns a list of arguments used in each call to FileSystemMock.RemoveAll.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRemoveAll *mFileSystemMockRemoveAll) Calls() []*FileSystemMockRemoveAllParams {
	mmRemoveAll.mutex.RLock()

	argCopy := make([]*FileSystemMockRemoveAllParams, len(mmRemoveAll.callArgs))
	copy(argCopy, mmRemoveAll.callArgs)

	mmRemoveAll.mutex.RUnlock()

	return argCopy
}

// MinimockRemoveAllDone returns true if the count of the RemoveAll invocations corresponds
// the number of defined expectations
func (m *FileSystemMock) MinimockRemoveAllDone() bool {
	for _, e := range m.RemoveAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveAllMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRemoveAllCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoveAll != nil && mm_atomic.LoadUint64(&m.afterRemoveAllCounter) < 1 {
		return false
	}
	return true
}

// MinimockRemoveAllInspect logs each unmet expectation
func (m *FileSystemMock) MinimockRemoveAllInspect() {
	for _, e := range m.RemoveAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FileSystemMock.RemoveAll with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveAllMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRemoveAllCounter) < 1 {
		if m.RemoveAllMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FileSystemMock.RemoveAll")
		} else {
			m.t.Errorf("Expected call to FileSystemMock.RemoveAll with params: %#v", *m.RemoveAllMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoveAll != nil && mm_atomic.LoadUint64(&m.afterRemoveAllCounter) < 1 {
		m.t.Error("Expected call to FileSystemMock.RemoveAll")
	}
}

type mFileSystemMockRename struct {
	mock               *FileSystemMock
	defaultExpectation *FileSystemMockRenameExpectation
	expectations       []*FileSystemMockRenameExpectation

	callArgs []*FileSystemMockRenameParams
	mutex    sync.RWMutex
}

// FileSystemMockRenameExpectation specifies expectation struct of the FileSystem.Rename
type FileSystemMockRenameExpectation struct {
	mock    *FileSystemMock
	params  *FileSystemMockRenameParams
	results *FileSystemMockRenameResults
	Counter uint64
}

// FileSystemMockRenameParams contains parameters of the FileSystem.Rename
type FileSystemMockRenameParams struct {
	old string
	new string
}

// FileSystemMockRenameResults contains results of the FileSystem.Rename
type FileSystemMockRenameResults struct {
	err error
}

// Expect sets up expected params for FileSystem.Rename
func (mmRename *mFileSystemMockRename) Expect(old string, new string) *mFileSystemMockRename {
	if mmRename.mock.funcRename != nil {
		mmRename.mock.t.Fatalf("FileSystemMock.Rename mock is already set by Set")
	}

	if mmRename.defaultExpectation == nil {
		mmRename.defaultExpectation = &FileSystemMockRenameExpectation{}
	}

	mmRename.defaultExpectation.params = &FileSystemMockRenameParams{old, new}
	for _, e := range mmRename.expectations {
		if minimock.Equal(e.params, mmRename.defaultExpectation.params) {
			mmRename.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRename.defaultExpectation.params)
		}
	}

	return mmRename
}

// Return sets up results that will be returned by FileSystem.Rename
func (mmRename *mFileSystemMockRename) Return(err error) *FileSystemMock {
	if mmRename.mock.funcRename != nil {
		mmRename.mock.t.Fatalf("FileSystemMock.Rename mock is already set by Set")
	}

	if mmRename.defaultExpectation == nil {
		mmRename.defaultExpectation = &FileSystemMockRenameExpectation{mock: mmRename.mock}
	}
	mmRename.defaultExpectation.results = &FileSystemMockRenameResults{err}
	return mmRename.mock
}

//Set uses given function f to mock the FileSystem.Rename method
func (mmRename *mFileSystemMockRename) Set(f func(old string, new string) (err error)) *FileSystemMock {
	if mmRename.defaultExpectation != nil {
		mmRename.mock.t.Fatalf("Default expectation is already set for the FileSystem.Rename method")
	}

	if len(mmRename.expectations) > 0 {
		mmRename.mock.t.Fatalf("Some expectations are already set for the FileSystem.Rename method")
	}

	mmRename.mock.funcRename = f
	return mmRename.mock
}

// When sets expectation for the FileSystem.Rename which will trigger the result defined by the following
// Then helper
func (mmRename *mFileSystemMockRename) When(old string, new string) *FileSystemMockRenameExpectation {
	if mmRename.mock.funcRename != nil {
		mmRename.mock.t.Fatalf("FileSystemMock.Rename mock is already set by Set")
	}

	expectation := &FileSystemMockRenameExpectation{
		mock:   mmRename.mock,
		params: &FileSystemMockRenameParams{old, new},
	}
	mmRename.expectations = append(mmRename.expectations, expectation)
	return expectation
}

// Then sets up FileSystem.Rename return parameters for the expectation previously defined by the When method
func (e *FileSystemMockRenameExpectation) Then(err error) *FileSystemMock {
	e.results = &FileSystemMockRenameResults{err}
	return e.mock
}

// Rename implements FileSystem
func (mmRename *FileSystemMock) Rename(old string, new string) (err error) {
	mm_atomic.AddUint64(&mmRename.beforeRenameCounter, 1)
	defer mm_atomic.AddUint64(&mmRename.afterRenameCounter, 1)

	params := &FileSystemMockRenameParams{old, new}

	// Record call args
	mmRename.RenameMock.mutex.Lock()
	mmRename.RenameMock.callArgs = append(mmRename.RenameMock.callArgs, params)
	mmRename.RenameMock.mutex.Unlock()

	for _, e := range mmRename.RenameMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRename.RenameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRename.RenameMock.defaultExpectation.Counter, 1)
		want := mmRename.RenameMock.defaultExpectation.params
		got := FileSystemMockRenameParams{old, new}
		if want != nil && !minimock.Equal(*want, got) {
			mmRename.t.Errorf("FileSystemMock.Rename got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmRename.RenameMock.defaultExpectation.results
		if results == nil {
			mmRename.t.Fatal("No results are set for the FileSystemMock.Rename")
		}
		return (*results).err
	}
	if mmRename.funcRename != nil {
		return mmRename.funcRename(old, new)
	}
	mmRename.t.Fatalf("Unexpected call to FileSystemMock.Rename. %v %v", old, new)
	return
}

// RenameAfterCounter returns a count of finished FileSystemMock.Rename invocations
func (mmRename *FileSystemMock) RenameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRename.afterRenameCounter)
}

// RenameBeforeCounter returns a count of FileSystemMock.Rename invocations
func (mmRename *FileSystemMock) RenameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRename.beforeRenameCounter)
}

// Calls returns a list of arguments used in each call to FileSystemMock.Rename.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRename *mFileSystemMockRename) Calls() []*FileSystemMockRenameParams {
	mmRename.mutex.RLock()

	argCopy := make([]*FileSystemMockRenameParams, len(mmRename.callArgs))
	copy(argCopy, mmRename.callArgs)

	mmRename.mutex.RUnlock()

	return argCopy
}

// MinimockRenameDone returns true if the count of the Rename invocations corresponds
// the number of defined expectations
func (m *FileSystemMock) MinimockRenameDone() bool {
	for _, e := range m.RenameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RenameMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRenameCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRename != nil && mm_atomic.LoadUint64(&m.afterRenameCounter) < 1 {
		return false
	}
	return true
}

// MinimockRenameInspect logs each unmet expectation
func (m *FileSystemMock) MinimockRenameInspect() {
	for _, e := range m.RenameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FileSystemMock.Rename with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RenameMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRenameCounter) < 1 {
		if m.RenameMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FileSystemMock.Rename")
		} else {
			m.t.Errorf("Expected call to FileSystemMock.Rename with params: %#v", *m.RenameMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRename != nil && mm_atomic.LoadUint64(&m.afterRenameCounter) < 1 {
		m.t.Error("Expected call to FileSystemMock.Rename")
	}
}

type mFileSystemMockStat struct {
	mock               *FileSystemMock
	defaultExpectation *FileSystemMockStatExpectation
	expectations       []*FileSystemMockStatExpectation

	callArgs []*FileSystemMockStatParams
	mutex    sync.RWMutex
}

// FileSystemMockStatExpectation specifies expectation struct of the FileSystem.Stat
type FileSystemMockStatExpectation struct {
	mock    *FileSystemMock
	params  *FileSystemMockStatParams
	results *FileSystemMockStatResults
	Counter uint64
}

// FileSystemMockStatParams contains parameters of the FileSystem.Stat
type FileSystemMockStatParams struct {
	name string
}

// FileSystemMockStatResults contains results of the FileSystem.Stat
type FileSystemMockStatResults struct {
	f1  os.FileInfo
	err error
}

// Expect sets up expected params for FileSystem.Stat
func (mmStat *mFileSystemMockStat) Expect(name string) *mFileSystemMockStat {
	if mmStat.mock.funcStat != nil {
		mmStat.mock.t.Fatalf("FileSystemMock.Stat mock is already set by Set")
	}

	if mmStat.defaultExpectation == nil {
		mmStat.defaultExpectation = &FileSystemMockStatExpectation{}
	}

	mmStat.defaultExpectation.params = &FileSystemMockStatParams{name}
	for _, e := range mmStat.expectations {
		if minimock.Equal(e.params, mmStat.defaultExpectation.params) {
			mmStat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmStat.defaultExpectation.params)
		}
	}

	return mmStat
}

// Return sets up results that will be returned by FileSystem.Stat
func (mmStat *mFileSystemMockStat) Return(f1 os.FileInfo, err error) *FileSystemMock {
	if mmStat.mock.funcStat != nil {
		mmStat.mock.t.Fatalf("FileSystemMock.Stat mock is already set by Set")
	}

	if mmStat.defaultExpectation == nil {
		mmStat.defaultExpectation = &FileSystemMockStatExpectation{mock: mmStat.mock}
	}
	mmStat.defaultExpectation.results = &FileSystemMockStatResults{f1, err}
	return mmStat.mock
}

//Set uses given function f to mock the FileSystem.Stat method
func (mmStat *mFileSystemMockStat) Set(f func(name string) (f1 os.FileInfo, err error)) *FileSystemMock {
	if mmStat.defaultExpectation != nil {
		mmStat.mock.t.Fatalf("Default expectation is already set for the FileSystem.Stat method")
	}

	if len(mmStat.expectations) > 0 {
		mmStat.mock.t.Fatalf("Some expectations are already set for the FileSystem.Stat method")
	}

	mmStat.mock.funcStat = f
	return mmStat.mock
}

// When sets expectation for the FileSystem.Stat which will trigger the result defined by the following
// Then helper
func (mmStat *mFileSystemMockStat) When(name string) *FileSystemMockStatExpectation {
	if mmStat.mock.funcStat != nil {
		mmStat.mock.t.Fatalf("FileSystemMock.Stat mock is already set by Set")
	}

	expectation := &FileSystemMockStatExpectation{
		mock:   mmStat.mock,
		params: &FileSystemMockStatParams{name},
	}
	mmStat.expectations = append(mmStat.expectations, expectation)
	return expectation
}

// Then sets up FileSystem.Stat return parameters for the expectation previously defined by the When method
func (e *FileSystemMockStatExpectation) Then(f1 os.FileInfo, err error) *FileSystemMock {
	e.results = &FileSystemMockStatResults{f1, err}
	return e.mock
}

// Stat implements FileSystem
func (mmStat *FileSystemMock) Stat(name string) (f1 os.FileInfo, err error) {
	mm_atomic.AddUint64(&mmStat.beforeStatCounter, 1)
	defer mm_atomic.AddUint64(&mmStat.afterStatCounter, 1)

	params := &FileSystemMockStatParams{name}

	// Record call args
	mmStat.StatMock.mutex.Lock()
	mmStat.StatMock.callArgs = append(mmStat.StatMock.callArgs, params)
	mmStat.StatMock.mutex.Unlock()

	for _, e := range mmStat.StatMock.expectations {
		if minimock.Equal(e.params, params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.f1, e.results.err
		}
	}

	if mmStat.StatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStat.StatMock.defaultExpectation.Counter, 1)
		want := mmStat.StatMock.defaultExpectation.params
		got := FileSystemMockStatParams{name}
		if want != nil && !minimock.Equal(*want, got) {
			mmStat.t.Errorf("FileSystemMock.Stat got unexpected parameters, want: %#v, got: %#v%s\n", *want, got, minimock.Diff(*want, got))
		}

		results := mmStat.StatMock.defaultExpectation.results
		if results == nil {
			mmStat.t.Fatal("No results are set for the FileSystemMock.Stat")
		}
		return (*results).f1, (*results).err
	}
	if mmStat.funcStat != nil {
		return mmStat.funcStat(name)
	}
	mmStat.t.Fatalf("Unexpected call to FileSystemMock.Stat. %v", name)
	return
}

// StatAfterCounter returns a count of finished FileSystemMock.Stat invocations
func (mmStat *FileSystemMock) StatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStat.afterStatCounter)
}

// StatBeforeCounter returns a count of FileSystemMock.Stat invocations
func (mmStat *FileSystemMock) StatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStat.beforeStatCounter)
}

// Calls returns a list of arguments used in each call to FileSystemMock.Stat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmStat *mFileSystemMockStat) Calls() []*FileSystemMockStatParams {
	mmStat.mutex.RLock()

	argCopy := make([]*FileSystemMockStatParams, len(mmStat.callArgs))
	copy(argCopy, mmStat.callArgs)

	mmStat.mutex.RUnlock()

	return argCopy
}

// MinimockStatDone returns true if the count of the Stat invocations corresponds
// the number of defined expectations
func (m *FileSystemMock) MinimockStatDone() bool {
	for _, e := range m.StatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStatCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStat != nil && mm_atomic.LoadUint64(&m.afterStatCounter) < 1 {
		return false
	}
	return true
}

// MinimockStatInspect logs each unmet expectation
func (m *FileSystemMock) MinimockStatInspect() {
	for _, e := range m.StatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FileSystemMock.Stat with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStatCounter) < 1 {
		if m.StatMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FileSystemMock.Stat")
		} else {
			m.t.Errorf("Expected call to FileSystemMock.Stat with params: %#v", *m.StatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStat != nil && mm_atomic.LoadUint64(&m.afterStatCounter) < 1 {
		m.t.Error("Expected call to FileSystemMock.Stat")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *FileSystemMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCreateInspect()

		m.MinimockMkdirInspect()

		m.MinimockMkdirAllInspect()

		m.MinimockOpenInspect()

		m.MinimockOpenFileInspect()

		m.MinimockRemoveInspect()

		m.MinimockRemoveAllInspect()

		m.MinimockRenameInspect()

		m.MinimockStatInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *FileSystemMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *FileSystemMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockMkdirDone() &&
		m.MinimockMkdirAllDone() &&
		m.MinimockOpenDone() &&
		m.MinimockOpenFileDone() &&
		m.MinimockRemoveDone() &&
		m.MinimockRemoveAllDone() &&
		m.MinimockRenameDone() &&
		m.MinimockStatDone()
}
