package fs

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"os"
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// FileMock implements File
type FileMock struct {
	t minimock.Tester

	funcChdir          func() (err error)
	inspectFuncChdir   func()
	afterChdirCounter  uint64
	beforeChdirCounter uint64
	ChdirMock          mFileMockChdir

	funcChmod          func(mode os.FileMode) (err error)
	inspectFuncChmod   func(mode os.FileMode)
	afterChmodCounter  uint64
	beforeChmodCounter uint64
	ChmodMock          mFileMockChmod

	funcChown          func(uid int, gid int) (err error)
	inspectFuncChown   func(uid int, gid int)
	afterChownCounter  uint64
	beforeChownCounter uint64
	ChownMock          mFileMockChown

	funcClose          func() (err error)
	inspectFuncClose   func()
	afterCloseCounter  uint64
	beforeCloseCounter uint64
	CloseMock          mFileMockClose

	funcFd          func() (u1 uintptr)
	inspectFuncFd   func()
	afterFdCounter  uint64
	beforeFdCounter uint64
	FdMock          mFileMockFd

	funcName          func() (s1 string)
	inspectFuncName   func()
	afterNameCounter  uint64
	beforeNameCounter uint64
	NameMock          mFileMockName

	funcRead          func(b []byte) (n int, err error)
	inspectFuncRead   func(b []byte)
	afterReadCounter  uint64
	beforeReadCounter uint64
	ReadMock          mFileMockRead

	funcReadAt          func(b []byte, off int64) (n int, err error)
	inspectFuncReadAt   func(b []byte, off int64)
	afterReadAtCounter  uint64
	beforeReadAtCounter uint64
	ReadAtMock          mFileMockReadAt

	funcReaddir          func(n int) (fa1 []os.FileInfo, err error)
	inspectFuncReaddir   func(n int)
	afterReaddirCounter  uint64
	beforeReaddirCounter uint64
	ReaddirMock          mFileMockReaddir

	funcReaddirnames          func(n int) (names []string, err error)
	inspectFuncReaddirnames   func(n int)
	afterReaddirnamesCounter  uint64
	beforeReaddirnamesCounter uint64
	ReaddirnamesMock          mFileMockReaddirnames

	funcSeek          func(offset int64, whence int) (ret int64, err error)
	inspectFuncSeek   func(offset int64, whence int)
	afterSeekCounter  uint64
	beforeSeekCounter uint64
	SeekMock          mFileMockSeek

	funcSetDeadline          func(t time.Time) (err error)
	inspectFuncSetDeadline   func(t time.Time)
	afterSetDeadlineCounter  uint64
	beforeSetDeadlineCounter uint64
	SetDeadlineMock          mFileMockSetDeadline

	funcSetReadDeadline          func(t time.Time) (err error)
	inspectFuncSetReadDeadline   func(t time.Time)
	afterSetReadDeadlineCounter  uint64
	beforeSetReadDeadlineCounter uint64
	SetReadDeadlineMock          mFileMockSetReadDeadline

	funcSetWriteDeadline          func(t time.Time) (err error)
	inspectFuncSetWriteDeadline   func(t time.Time)
	afterSetWriteDeadlineCounter  uint64
	beforeSetWriteDeadlineCounter uint64
	SetWriteDeadlineMock          mFileMockSetWriteDeadline

	funcStat          func() (f1 os.FileInfo, err error)
	inspectFuncStat   func()
	afterStatCounter  uint64
	beforeStatCounter uint64
	StatMock          mFileMockStat

	funcSync          func() (err error)
	inspectFuncSync   func()
	afterSyncCounter  uint64
	beforeSyncCounter uint64
	SyncMock          mFileMockSync

	funcTruncate          func(size int64) (err error)
	inspectFuncTruncate   func(size int64)
	afterTruncateCounter  uint64
	beforeTruncateCounter uint64
	TruncateMock          mFileMockTruncate

	funcWrite          func(b []byte) (n int, err error)
	inspectFuncWrite   func(b []byte)
	afterWriteCounter  uint64
	beforeWriteCounter uint64
	WriteMock          mFileMockWrite

	funcWriteAt          func(b []byte, off int64) (n int, err error)
	inspectFuncWriteAt   func(b []byte, off int64)
	afterWriteAtCounter  uint64
	beforeWriteAtCounter uint64
	WriteAtMock          mFileMockWriteAt

	funcWriteString          func(s string) (n int, err error)
	inspectFuncWriteString   func(s string)
	afterWriteStringCounter  uint64
	beforeWriteStringCounter uint64
	WriteStringMock          mFileMockWriteString
}

// NewFileMock returns a mock for File
func NewFileMock(t minimock.Tester) *FileMock {
	m := &FileMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ChdirMock = mFileMockChdir{mock: m}

	m.ChmodMock = mFileMockChmod{mock: m}
	m.ChmodMock.callArgs = []*FileMockChmodParams{}

	m.ChownMock = mFileMockChown{mock: m}
	m.ChownMock.callArgs = []*FileMockChownParams{}

	m.CloseMock = mFileMockClose{mock: m}

	m.FdMock = mFileMockFd{mock: m}

	m.NameMock = mFileMockName{mock: m}

	m.ReadMock = mFileMockRead{mock: m}
	m.ReadMock.callArgs = []*FileMockReadParams{}

	m.ReadAtMock = mFileMockReadAt{mock: m}
	m.ReadAtMock.callArgs = []*FileMockReadAtParams{}

	m.ReaddirMock = mFileMockReaddir{mock: m}
	m.ReaddirMock.callArgs = []*FileMockReaddirParams{}

	m.ReaddirnamesMock = mFileMockReaddirnames{mock: m}
	m.ReaddirnamesMock.callArgs = []*FileMockReaddirnamesParams{}

	m.SeekMock = mFileMockSeek{mock: m}
	m.SeekMock.callArgs = []*FileMockSeekParams{}

	m.SetDeadlineMock = mFileMockSetDeadline{mock: m}
	m.SetDeadlineMock.callArgs = []*FileMockSetDeadlineParams{}

	m.SetReadDeadlineMock = mFileMockSetReadDeadline{mock: m}
	m.SetReadDeadlineMock.callArgs = []*FileMockSetReadDeadlineParams{}

	m.SetWriteDeadlineMock = mFileMockSetWriteDeadline{mock: m}
	m.SetWriteDeadlineMock.callArgs = []*FileMockSetWriteDeadlineParams{}

	m.StatMock = mFileMockStat{mock: m}

	m.SyncMock = mFileMockSync{mock: m}

	m.TruncateMock = mFileMockTruncate{mock: m}
	m.TruncateMock.callArgs = []*FileMockTruncateParams{}

	m.WriteMock = mFileMockWrite{mock: m}
	m.WriteMock.callArgs = []*FileMockWriteParams{}

	m.WriteAtMock = mFileMockWriteAt{mock: m}
	m.WriteAtMock.callArgs = []*FileMockWriteAtParams{}

	m.WriteStringMock = mFileMockWriteString{mock: m}
	m.WriteStringMock.callArgs = []*FileMockWriteStringParams{}

	return m
}

type mFileMockChdir struct {
	mock               *FileMock
	defaultExpectation *FileMockChdirExpectation
	expectations       []*FileMockChdirExpectation
}

// FileMockChdirExpectation specifies expectation struct of the File.Chdir
type FileMockChdirExpectation struct {
	mock *FileMock

	results *FileMockChdirResults
	Counter uint64
}

// FileMockChdirResults contains results of the File.Chdir
type FileMockChdirResults struct {
	err error
}

// Expect sets up expected params for File.Chdir
func (mmChdir *mFileMockChdir) Expect() *mFileMockChdir {
	if mmChdir.mock.funcChdir != nil {
		mmChdir.mock.t.Fatalf("FileMock.Chdir mock is already set by Set")
	}

	if mmChdir.defaultExpectation == nil {
		mmChdir.defaultExpectation = &FileMockChdirExpectation{}
	}

	return mmChdir
}

// Inspect accepts an inspector function that has same arguments as the File.Chdir
func (mmChdir *mFileMockChdir) Inspect(f func()) *mFileMockChdir {
	if mmChdir.mock.inspectFuncChdir != nil {
		mmChdir.mock.t.Fatalf("Inspect function is already set for FileMock.Chdir")
	}

	mmChdir.mock.inspectFuncChdir = f

	return mmChdir
}

// Return sets up results that will be returned by File.Chdir
func (mmChdir *mFileMockChdir) Return(err error) *FileMock {
	if mmChdir.mock.funcChdir != nil {
		mmChdir.mock.t.Fatalf("FileMock.Chdir mock is already set by Set")
	}

	if mmChdir.defaultExpectation == nil {
		mmChdir.defaultExpectation = &FileMockChdirExpectation{mock: mmChdir.mock}
	}
	mmChdir.defaultExpectation.results = &FileMockChdirResults{err}
	return mmChdir.mock
}

//Set uses given function f to mock the File.Chdir method
func (mmChdir *mFileMockChdir) Set(f func() (err error)) *FileMock {
	if mmChdir.defaultExpectation != nil {
		mmChdir.mock.t.Fatalf("Default expectation is already set for the File.Chdir method")
	}

	if len(mmChdir.expectations) > 0 {
		mmChdir.mock.t.Fatalf("Some expectations are already set for the File.Chdir method")
	}

	mmChdir.mock.funcChdir = f
	return mmChdir.mock
}

// Chdir implements File
func (mmChdir *FileMock) Chdir() (err error) {
	mm_atomic.AddUint64(&mmChdir.beforeChdirCounter, 1)
	defer mm_atomic.AddUint64(&mmChdir.afterChdirCounter, 1)

	if mmChdir.inspectFuncChdir != nil {
		mmChdir.inspectFuncChdir()
	}

	if mmChdir.ChdirMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmChdir.ChdirMock.defaultExpectation.Counter, 1)

		mm_results := mmChdir.ChdirMock.defaultExpectation.results
		if mm_results == nil {
			mmChdir.t.Fatal("No results are set for the FileMock.Chdir")
		}
		return (*mm_results).err
	}
	if mmChdir.funcChdir != nil {
		return mmChdir.funcChdir()
	}
	mmChdir.t.Fatalf("Unexpected call to FileMock.Chdir.")
	return
}

// ChdirAfterCounter returns a count of finished FileMock.Chdir invocations
func (mmChdir *FileMock) ChdirAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChdir.afterChdirCounter)
}

// ChdirBeforeCounter returns a count of FileMock.Chdir invocations
func (mmChdir *FileMock) ChdirBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChdir.beforeChdirCounter)
}

// MinimockChdirDone returns true if the count of the Chdir invocations corresponds
// the number of defined expectations
func (m *FileMock) MinimockChdirDone() bool {
	for _, e := range m.ChdirMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ChdirMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterChdirCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcChdir != nil && mm_atomic.LoadUint64(&m.afterChdirCounter) < 1 {
		return false
	}
	return true
}

// MinimockChdirInspect logs each unmet expectation
func (m *FileMock) MinimockChdirInspect() {
	for _, e := range m.ChdirMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to FileMock.Chdir")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ChdirMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterChdirCounter) < 1 {
		m.t.Error("Expected call to FileMock.Chdir")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcChdir != nil && mm_atomic.LoadUint64(&m.afterChdirCounter) < 1 {
		m.t.Error("Expected call to FileMock.Chdir")
	}
}

type mFileMockChmod struct {
	mock               *FileMock
	defaultExpectation *FileMockChmodExpectation
	expectations       []*FileMockChmodExpectation

	callArgs []*FileMockChmodParams
	mutex    sync.RWMutex
}

// FileMockChmodExpectation specifies expectation struct of the File.Chmod
type FileMockChmodExpectation struct {
	mock    *FileMock
	params  *FileMockChmodParams
	results *FileMockChmodResults
	Counter uint64
}

// FileMockChmodParams contains parameters of the File.Chmod
type FileMockChmodParams struct {
	mode os.FileMode
}

// FileMockChmodResults contains results of the File.Chmod
type FileMockChmodResults struct {
	err error
}

// Expect sets up expected params for File.Chmod
func (mmChmod *mFileMockChmod) Expect(mode os.FileMode) *mFileMockChmod {
	if mmChmod.mock.funcChmod != nil {
		mmChmod.mock.t.Fatalf("FileMock.Chmod mock is already set by Set")
	}

	if mmChmod.defaultExpectation == nil {
		mmChmod.defaultExpectation = &FileMockChmodExpectation{}
	}

	mmChmod.defaultExpectation.params = &FileMockChmodParams{mode}
	for _, e := range mmChmod.expectations {
		if minimock.Equal(e.params, mmChmod.defaultExpectation.params) {
			mmChmod.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmChmod.defaultExpectation.params)
		}
	}

	return mmChmod
}

// Inspect accepts an inspector function that has same arguments as the File.Chmod
func (mmChmod *mFileMockChmod) Inspect(f func(mode os.FileMode)) *mFileMockChmod {
	if mmChmod.mock.inspectFuncChmod != nil {
		mmChmod.mock.t.Fatalf("Inspect function is already set for FileMock.Chmod")
	}

	mmChmod.mock.inspectFuncChmod = f

	return mmChmod
}

// Return sets up results that will be returned by File.Chmod
func (mmChmod *mFileMockChmod) Return(err error) *FileMock {
	if mmChmod.mock.funcChmod != nil {
		mmChmod.mock.t.Fatalf("FileMock.Chmod mock is already set by Set")
	}

	if mmChmod.defaultExpectation == nil {
		mmChmod.defaultExpectation = &FileMockChmodExpectation{mock: mmChmod.mock}
	}
	mmChmod.defaultExpectation.results = &FileMockChmodResults{err}
	return mmChmod.mock
}

//Set uses given function f to mock the File.Chmod method
func (mmChmod *mFileMockChmod) Set(f func(mode os.FileMode) (err error)) *FileMock {
	if mmChmod.defaultExpectation != nil {
		mmChmod.mock.t.Fatalf("Default expectation is already set for the File.Chmod method")
	}

	if len(mmChmod.expectations) > 0 {
		mmChmod.mock.t.Fatalf("Some expectations are already set for the File.Chmod method")
	}

	mmChmod.mock.funcChmod = f
	return mmChmod.mock
}

// When sets expectation for the File.Chmod which will trigger the result defined by the following
// Then helper
func (mmChmod *mFileMockChmod) When(mode os.FileMode) *FileMockChmodExpectation {
	if mmChmod.mock.funcChmod != nil {
		mmChmod.mock.t.Fatalf("FileMock.Chmod mock is already set by Set")
	}

	expectation := &FileMockChmodExpectation{
		mock:   mmChmod.mock,
		params: &FileMockChmodParams{mode},
	}
	mmChmod.expectations = append(mmChmod.expectations, expectation)
	return expectation
}

// Then sets up File.Chmod return parameters for the expectation previously defined by the When method
func (e *FileMockChmodExpectation) Then(err error) *FileMock {
	e.results = &FileMockChmodResults{err}
	return e.mock
}

// Chmod implements File
func (mmChmod *FileMock) Chmod(mode os.FileMode) (err error) {
	mm_atomic.AddUint64(&mmChmod.beforeChmodCounter, 1)
	defer mm_atomic.AddUint64(&mmChmod.afterChmodCounter, 1)

	if mmChmod.inspectFuncChmod != nil {
		mmChmod.inspectFuncChmod(mode)
	}

	mm_params := &FileMockChmodParams{mode}

	// Record call args
	mmChmod.ChmodMock.mutex.Lock()
	mmChmod.ChmodMock.callArgs = append(mmChmod.ChmodMock.callArgs, mm_params)
	mmChmod.ChmodMock.mutex.Unlock()

	for _, e := range mmChmod.ChmodMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmChmod.ChmodMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmChmod.ChmodMock.defaultExpectation.Counter, 1)
		mm_want := mmChmod.ChmodMock.defaultExpectation.params
		mm_got := FileMockChmodParams{mode}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmChmod.t.Errorf("FileMock.Chmod got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmChmod.ChmodMock.defaultExpectation.results
		if mm_results == nil {
			mmChmod.t.Fatal("No results are set for the FileMock.Chmod")
		}
		return (*mm_results).err
	}
	if mmChmod.funcChmod != nil {
		return mmChmod.funcChmod(mode)
	}
	mmChmod.t.Fatalf("Unexpected call to FileMock.Chmod. %v", mode)
	return
}

// ChmodAfterCounter returns a count of finished FileMock.Chmod invocations
func (mmChmod *FileMock) ChmodAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChmod.afterChmodCounter)
}

// ChmodBeforeCounter returns a count of FileMock.Chmod invocations
func (mmChmod *FileMock) ChmodBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChmod.beforeChmodCounter)
}

// Calls returns a list of arguments used in each call to FileMock.Chmod.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmChmod *mFileMockChmod) Calls() []*FileMockChmodParams {
	mmChmod.mutex.RLock()

	argCopy := make([]*FileMockChmodParams, len(mmChmod.callArgs))
	copy(argCopy, mmChmod.callArgs)

	mmChmod.mutex.RUnlock()

	return argCopy
}

// MinimockChmodDone returns true if the count of the Chmod invocations corresponds
// the number of defined expectations
func (m *FileMock) MinimockChmodDone() bool {
	for _, e := range m.ChmodMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ChmodMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterChmodCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcChmod != nil && mm_atomic.LoadUint64(&m.afterChmodCounter) < 1 {
		return false
	}
	return true
}

// MinimockChmodInspect logs each unmet expectation
func (m *FileMock) MinimockChmodInspect() {
	for _, e := range m.ChmodMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FileMock.Chmod with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ChmodMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterChmodCounter) < 1 {
		if m.ChmodMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FileMock.Chmod")
		} else {
			m.t.Errorf("Expected call to FileMock.Chmod with params: %#v", *m.ChmodMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcChmod != nil && mm_atomic.LoadUint64(&m.afterChmodCounter) < 1 {
		m.t.Error("Expected call to FileMock.Chmod")
	}
}

type mFileMockChown struct {
	mock               *FileMock
	defaultExpectation *FileMockChownExpectation
	expectations       []*FileMockChownExpectation

	callArgs []*FileMockChownParams
	mutex    sync.RWMutex
}

// FileMockChownExpectation specifies expectation struct of the File.Chown
type FileMockChownExpectation struct {
	mock    *FileMock
	params  *FileMockChownParams
	results *FileMockChownResults
	Counter uint64
}

// FileMockChownParams contains parameters of the File.Chown
type FileMockChownParams struct {
	uid int
	gid int
}

// FileMockChownResults contains results of the File.Chown
type FileMockChownResults struct {
	err error
}

// Expect sets up expected params for File.Chown
func (mmChown *mFileMockChown) Expect(uid int, gid int) *mFileMockChown {
	if mmChown.mock.funcChown != nil {
		mmChown.mock.t.Fatalf("FileMock.Chown mock is already set by Set")
	}

	if mmChown.defaultExpectation == nil {
		mmChown.defaultExpectation = &FileMockChownExpectation{}
	}

	mmChown.defaultExpectation.params = &FileMockChownParams{uid, gid}
	for _, e := range mmChown.expectations {
		if minimock.Equal(e.params, mmChown.defaultExpectation.params) {
			mmChown.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmChown.defaultExpectation.params)
		}
	}

	return mmChown
}

// Inspect accepts an inspector function that has same arguments as the File.Chown
func (mmChown *mFileMockChown) Inspect(f func(uid int, gid int)) *mFileMockChown {
	if mmChown.mock.inspectFuncChown != nil {
		mmChown.mock.t.Fatalf("Inspect function is already set for FileMock.Chown")
	}

	mmChown.mock.inspectFuncChown = f

	return mmChown
}

// Return sets up results that will be returned by File.Chown
func (mmChown *mFileMockChown) Return(err error) *FileMock {
	if mmChown.mock.funcChown != nil {
		mmChown.mock.t.Fatalf("FileMock.Chown mock is already set by Set")
	}

	if mmChown.defaultExpectation == nil {
		mmChown.defaultExpectation = &FileMockChownExpectation{mock: mmChown.mock}
	}
	mmChown.defaultExpectation.results = &FileMockChownResults{err}
	return mmChown.mock
}

//Set uses given function f to mock the File.Chown method
func (mmChown *mFileMockChown) Set(f func(uid int, gid int) (err error)) *FileMock {
	if mmChown.defaultExpectation != nil {
		mmChown.mock.t.Fatalf("Default expectation is already set for the File.Chown method")
	}

	if len(mmChown.expectations) > 0 {
		mmChown.mock.t.Fatalf("Some expectations are already set for the File.Chown method")
	}

	mmChown.mock.funcChown = f
	return mmChown.mock
}

// When sets expectation for the File.Chown which will trigger the result defined by the following
// Then helper
func (mmChown *mFileMockChown) When(uid int, gid int) *FileMockChownExpectation {
	if mmChown.mock.funcChown != nil {
		mmChown.mock.t.Fatalf("FileMock.Chown mock is already set by Set")
	}

	expectation := &FileMockChownExpectation{
		mock:   mmChown.mock,
		params: &FileMockChownParams{uid, gid},
	}
	mmChown.expectations = append(mmChown.expectations, expectation)
	return expectation
}

// Then sets up File.Chown return parameters for the expectation previously defined by the When method
func (e *FileMockChownExpectation) Then(err error) *FileMock {
	e.results = &FileMockChownResults{err}
	return e.mock
}

// Chown implements File
func (mmChown *FileMock) Chown(uid int, gid int) (err error) {
	mm_atomic.AddUint64(&mmChown.beforeChownCounter, 1)
	defer mm_atomic.AddUint64(&mmChown.afterChownCounter, 1)

	if mmChown.inspectFuncChown != nil {
		mmChown.inspectFuncChown(uid, gid)
	}

	mm_params := &FileMockChownParams{uid, gid}

	// Record call args
	mmChown.ChownMock.mutex.Lock()
	mmChown.ChownMock.callArgs = append(mmChown.ChownMock.callArgs, mm_params)
	mmChown.ChownMock.mutex.Unlock()

	for _, e := range mmChown.ChownMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmChown.ChownMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmChown.ChownMock.defaultExpectation.Counter, 1)
		mm_want := mmChown.ChownMock.defaultExpectation.params
		mm_got := FileMockChownParams{uid, gid}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmChown.t.Errorf("FileMock.Chown got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmChown.ChownMock.defaultExpectation.results
		if mm_results == nil {
			mmChown.t.Fatal("No results are set for the FileMock.Chown")
		}
		return (*mm_results).err
	}
	if mmChown.funcChown != nil {
		return mmChown.funcChown(uid, gid)
	}
	mmChown.t.Fatalf("Unexpected call to FileMock.Chown. %v %v", uid, gid)
	return
}

// ChownAfterCounter returns a count of finished FileMock.Chown invocations
func (mmChown *FileMock) ChownAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChown.afterChownCounter)
}

// ChownBeforeCounter returns a count of FileMock.Chown invocations
func (mmChown *FileMock) ChownBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChown.beforeChownCounter)
}

// Calls returns a list of arguments used in each call to FileMock.Chown.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmChown *mFileMockChown) Calls() []*FileMockChownParams {
	mmChown.mutex.RLock()

	argCopy := make([]*FileMockChownParams, len(mmChown.callArgs))
	copy(argCopy, mmChown.callArgs)

	mmChown.mutex.RUnlock()

	return argCopy
}

// MinimockChownDone returns true if the count of the Chown invocations corresponds
// the number of defined expectations
func (m *FileMock) MinimockChownDone() bool {
	for _, e := range m.ChownMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ChownMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterChownCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcChown != nil && mm_atomic.LoadUint64(&m.afterChownCounter) < 1 {
		return false
	}
	return true
}

// MinimockChownInspect logs each unmet expectation
func (m *FileMock) MinimockChownInspect() {
	for _, e := range m.ChownMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FileMock.Chown with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ChownMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterChownCounter) < 1 {
		if m.ChownMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FileMock.Chown")
		} else {
			m.t.Errorf("Expected call to FileMock.Chown with params: %#v", *m.ChownMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcChown != nil && mm_atomic.LoadUint64(&m.afterChownCounter) < 1 {
		m.t.Error("Expected call to FileMock.Chown")
	}
}

type mFileMockClose struct {
	mock               *FileMock
	defaultExpectation *FileMockCloseExpectation
	expectations       []*FileMockCloseExpectation
}

// FileMockCloseExpectation specifies expectation struct of the File.Close
type FileMockCloseExpectation struct {
	mock *FileMock

	results *FileMockCloseResults
	Counter uint64
}

// FileMockCloseResults contains results of the File.Close
type FileMockCloseResults struct {
	err error
}

// Expect sets up expected params for File.Close
func (mmClose *mFileMockClose) Expect() *mFileMockClose {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("FileMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &FileMockCloseExpectation{}
	}

	return mmClose
}

// Inspect accepts an inspector function that has same arguments as the File.Close
func (mmClose *mFileMockClose) Inspect(f func()) *mFileMockClose {
	if mmClose.mock.inspectFuncClose != nil {
		mmClose.mock.t.Fatalf("Inspect function is already set for FileMock.Close")
	}

	mmClose.mock.inspectFuncClose = f

	return mmClose
}

// Return sets up results that will be returned by File.Close
func (mmClose *mFileMockClose) Return(err error) *FileMock {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("FileMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &FileMockCloseExpectation{mock: mmClose.mock}
	}
	mmClose.defaultExpectation.results = &FileMockCloseResults{err}
	return mmClose.mock
}

//Set uses given function f to mock the File.Close method
func (mmClose *mFileMockClose) Set(f func() (err error)) *FileMock {
	if mmClose.defaultExpectation != nil {
		mmClose.mock.t.Fatalf("Default expectation is already set for the File.Close method")
	}

	if len(mmClose.expectations) > 0 {
		mmClose.mock.t.Fatalf("Some expectations are already set for the File.Close method")
	}

	mmClose.mock.funcClose = f
	return mmClose.mock
}

// Close implements File
func (mmClose *FileMock) Close() (err error) {
	mm_atomic.AddUint64(&mmClose.beforeCloseCounter, 1)
	defer mm_atomic.AddUint64(&mmClose.afterCloseCounter, 1)

	if mmClose.inspectFuncClose != nil {
		mmClose.inspectFuncClose()
	}

	if mmClose.CloseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClose.CloseMock.defaultExpectation.Counter, 1)

		mm_results := mmClose.CloseMock.defaultExpectation.results
		if mm_results == nil {
			mmClose.t.Fatal("No results are set for the FileMock.Close")
		}
		return (*mm_results).err
	}
	if mmClose.funcClose != nil {
		return mmClose.funcClose()
	}
	mmClose.t.Fatalf("Unexpected call to FileMock.Close.")
	return
}

// CloseAfterCounter returns a count of finished FileMock.Close invocations
func (mmClose *FileMock) CloseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.afterCloseCounter)
}

// CloseBeforeCounter returns a count of FileMock.Close invocations
func (mmClose *FileMock) CloseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.beforeCloseCounter)
}

// MinimockCloseDone returns true if the count of the Close invocations corresponds
// the number of defined expectations
func (m *FileMock) MinimockCloseDone() bool {
	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CloseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClose != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		return false
	}
	return true
}

// MinimockCloseInspect logs each unmet expectation
func (m *FileMock) MinimockCloseInspect() {
	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to FileMock.Close")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CloseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		m.t.Error("Expected call to FileMock.Close")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClose != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		m.t.Error("Expected call to FileMock.Close")
	}
}

type mFileMockFd struct {
	mock               *FileMock
	defaultExpectation *FileMockFdExpectation
	expectations       []*FileMockFdExpectation
}

// FileMockFdExpectation specifies expectation struct of the File.Fd
type FileMockFdExpectation struct {
	mock *FileMock

	results *FileMockFdResults
	Counter uint64
}

// FileMockFdResults contains results of the File.Fd
type FileMockFdResults struct {
	u1 uintptr
}

// Expect sets up expected params for File.Fd
func (mmFd *mFileMockFd) Expect() *mFileMockFd {
	if mmFd.mock.funcFd != nil {
		mmFd.mock.t.Fatalf("FileMock.Fd mock is already set by Set")
	}

	if mmFd.defaultExpectation == nil {
		mmFd.defaultExpectation = &FileMockFdExpectation{}
	}

	return mmFd
}

// Inspect accepts an inspector function that has same arguments as the File.Fd
func (mmFd *mFileMockFd) Inspect(f func()) *mFileMockFd {
	if mmFd.mock.inspectFuncFd != nil {
		mmFd.mock.t.Fatalf("Inspect function is already set for FileMock.Fd")
	}

	mmFd.mock.inspectFuncFd = f

	return mmFd
}

// Return sets up results that will be returned by File.Fd
func (mmFd *mFileMockFd) Return(u1 uintptr) *FileMock {
	if mmFd.mock.funcFd != nil {
		mmFd.mock.t.Fatalf("FileMock.Fd mock is already set by Set")
	}

	if mmFd.defaultExpectation == nil {
		mmFd.defaultExpectation = &FileMockFdExpectation{mock: mmFd.mock}
	}
	mmFd.defaultExpectation.results = &FileMockFdResults{u1}
	return mmFd.mock
}

//Set uses given function f to mock the File.Fd method
func (mmFd *mFileMockFd) Set(f func() (u1 uintptr)) *FileMock {
	if mmFd.defaultExpectation != nil {
		mmFd.mock.t.Fatalf("Default expectation is already set for the File.Fd method")
	}

	if len(mmFd.expectations) > 0 {
		mmFd.mock.t.Fatalf("Some expectations are already set for the File.Fd method")
	}

	mmFd.mock.funcFd = f
	return mmFd.mock
}

// Fd implements File
func (mmFd *FileMock) Fd() (u1 uintptr) {
	mm_atomic.AddUint64(&mmFd.beforeFdCounter, 1)
	defer mm_atomic.AddUint64(&mmFd.afterFdCounter, 1)

	if mmFd.inspectFuncFd != nil {
		mmFd.inspectFuncFd()
	}

	if mmFd.FdMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFd.FdMock.defaultExpectation.Counter, 1)

		mm_results := mmFd.FdMock.defaultExpectation.results
		if mm_results == nil {
			mmFd.t.Fatal("No results are set for the FileMock.Fd")
		}
		return (*mm_results).u1
	}
	if mmFd.funcFd != nil {
		return mmFd.funcFd()
	}
	mmFd.t.Fatalf("Unexpected call to FileMock.Fd.")
	return
}

// FdAfterCounter returns a count of finished FileMock.Fd invocations
func (mmFd *FileMock) FdAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFd.afterFdCounter)
}

// FdBeforeCounter returns a count of FileMock.Fd invocations
func (mmFd *FileMock) FdBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFd.beforeFdCounter)
}

// MinimockFdDone returns true if the count of the Fd invocations corresponds
// the number of defined expectations
func (m *FileMock) MinimockFdDone() bool {
	for _, e := range m.FdMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FdMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFdCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFd != nil && mm_atomic.LoadUint64(&m.afterFdCounter) < 1 {
		return false
	}
	return true
}

// MinimockFdInspect logs each unmet expectation
func (m *FileMock) MinimockFdInspect() {
	for _, e := range m.FdMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to FileMock.Fd")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FdMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFdCounter) < 1 {
		m.t.Error("Expected call to FileMock.Fd")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFd != nil && mm_atomic.LoadUint64(&m.afterFdCounter) < 1 {
		m.t.Error("Expected call to FileMock.Fd")
	}
}

type mFileMockName struct {
	mock               *FileMock
	defaultExpectation *FileMockNameExpectation
	expectations       []*FileMockNameExpectation
}

// FileMockNameExpectation specifies expectation struct of the File.Name
type FileMockNameExpectation struct {
	mock *FileMock

	results *FileMockNameResults
	Counter uint64
}

// FileMockNameResults contains results of the File.Name
type FileMockNameResults struct {
	s1 string
}

// Expect sets up expected params for File.Name
func (mmName *mFileMockName) Expect() *mFileMockName {
	if mmName.mock.funcName != nil {
		mmName.mock.t.Fatalf("FileMock.Name mock is already set by Set")
	}

	if mmName.defaultExpectation == nil {
		mmName.defaultExpectation = &FileMockNameExpectation{}
	}

	return mmName
}

// Inspect accepts an inspector function that has same arguments as the File.Name
func (mmName *mFileMockName) Inspect(f func()) *mFileMockName {
	if mmName.mock.inspectFuncName != nil {
		mmName.mock.t.Fatalf("Inspect function is already set for FileMock.Name")
	}

	mmName.mock.inspectFuncName = f

	return mmName
}

// Return sets up results that will be returned by File.Name
func (mmName *mFileMockName) Return(s1 string) *FileMock {
	if mmName.mock.funcName != nil {
		mmName.mock.t.Fatalf("FileMock.Name mock is already set by Set")
	}

	if mmName.defaultExpectation == nil {
		mmName.defaultExpectation = &FileMockNameExpectation{mock: mmName.mock}
	}
	mmName.defaultExpectation.results = &FileMockNameResults{s1}
	return mmName.mock
}

//Set uses given function f to mock the File.Name method
func (mmName *mFileMockName) Set(f func() (s1 string)) *FileMock {
	if mmName.defaultExpectation != nil {
		mmName.mock.t.Fatalf("Default expectation is already set for the File.Name method")
	}

	if len(mmName.expectations) > 0 {
		mmName.mock.t.Fatalf("Some expectations are already set for the File.Name method")
	}

	mmName.mock.funcName = f
	return mmName.mock
}

// Name implements File
func (mmName *FileMock) Name() (s1 string) {
	mm_atomic.AddUint64(&mmName.beforeNameCounter, 1)
	defer mm_atomic.AddUint64(&mmName.afterNameCounter, 1)

	if mmName.inspectFuncName != nil {
		mmName.inspectFuncName()
	}

	if mmName.NameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmName.NameMock.defaultExpectation.Counter, 1)

		mm_results := mmName.NameMock.defaultExpectation.results
		if mm_results == nil {
			mmName.t.Fatal("No results are set for the FileMock.Name")
		}
		return (*mm_results).s1
	}
	if mmName.funcName != nil {
		return mmName.funcName()
	}
	mmName.t.Fatalf("Unexpected call to FileMock.Name.")
	return
}

// NameAfterCounter returns a count of finished FileMock.Name invocations
func (mmName *FileMock) NameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmName.afterNameCounter)
}

// NameBeforeCounter returns a count of FileMock.Name invocations
func (mmName *FileMock) NameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmName.beforeNameCounter)
}

// MinimockNameDone returns true if the count of the Name invocations corresponds
// the number of defined expectations
func (m *FileMock) MinimockNameDone() bool {
	for _, e := range m.NameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NameMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNameCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcName != nil && mm_atomic.LoadUint64(&m.afterNameCounter) < 1 {
		return false
	}
	return true
}

// MinimockNameInspect logs each unmet expectation
func (m *FileMock) MinimockNameInspect() {
	for _, e := range m.NameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to FileMock.Name")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NameMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNameCounter) < 1 {
		m.t.Error("Expected call to FileMock.Name")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcName != nil && mm_atomic.LoadUint64(&m.afterNameCounter) < 1 {
		m.t.Error("Expected call to FileMock.Name")
	}
}

type mFileMockRead struct {
	mock               *FileMock
	defaultExpectation *FileMockReadExpectation
	expectations       []*FileMockReadExpectation

	callArgs []*FileMockReadParams
	mutex    sync.RWMutex
}

// FileMockReadExpectation specifies expectation struct of the File.Read
type FileMockReadExpectation struct {
	mock    *FileMock
	params  *FileMockReadParams
	results *FileMockReadResults
	Counter uint64
}

// FileMockReadParams contains parameters of the File.Read
type FileMockReadParams struct {
	b []byte
}

// FileMockReadResults contains results of the File.Read
type FileMockReadResults struct {
	n   int
	err error
}

// Expect sets up expected params for File.Read
func (mmRead *mFileMockRead) Expect(b []byte) *mFileMockRead {
	if mmRead.mock.funcRead != nil {
		mmRead.mock.t.Fatalf("FileMock.Read mock is already set by Set")
	}

	if mmRead.defaultExpectation == nil {
		mmRead.defaultExpectation = &FileMockReadExpectation{}
	}

	mmRead.defaultExpectation.params = &FileMockReadParams{b}
	for _, e := range mmRead.expectations {
		if minimock.Equal(e.params, mmRead.defaultExpectation.params) {
			mmRead.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRead.defaultExpectation.params)
		}
	}

	return mmRead
}

// Inspect accepts an inspector function that has same arguments as the File.Read
func (mmRead *mFileMockRead) Inspect(f func(b []byte)) *mFileMockRead {
	if mmRead.mock.inspectFuncRead != nil {
		mmRead.mock.t.Fatalf("Inspect function is already set for FileMock.Read")
	}

	mmRead.mock.inspectFuncRead = f

	return mmRead
}

// Return sets up results that will be returned by File.Read
func (mmRead *mFileMockRead) Return(n int, err error) *FileMock {
	if mmRead.mock.funcRead != nil {
		mmRead.mock.t.Fatalf("FileMock.Read mock is already set by Set")
	}

	if mmRead.defaultExpectation == nil {
		mmRead.defaultExpectation = &FileMockReadExpectation{mock: mmRead.mock}
	}
	mmRead.defaultExpectation.results = &FileMockReadResults{n, err}
	return mmRead.mock
}

//Set uses given function f to mock the File.Read method
func (mmRead *mFileMockRead) Set(f func(b []byte) (n int, err error)) *FileMock {
	if mmRead.defaultExpectation != nil {
		mmRead.mock.t.Fatalf("Default expectation is already set for the File.Read method")
	}

	if len(mmRead.expectations) > 0 {
		mmRead.mock.t.Fatalf("Some expectations are already set for the File.Read method")
	}

	mmRead.mock.funcRead = f
	return mmRead.mock
}

// When sets expectation for the File.Read which will trigger the result defined by the following
// Then helper
func (mmRead *mFileMockRead) When(b []byte) *FileMockReadExpectation {
	if mmRead.mock.funcRead != nil {
		mmRead.mock.t.Fatalf("FileMock.Read mock is already set by Set")
	}

	expectation := &FileMockReadExpectation{
		mock:   mmRead.mock,
		params: &FileMockReadParams{b},
	}
	mmRead.expectations = append(mmRead.expectations, expectation)
	return expectation
}

// Then sets up File.Read return parameters for the expectation previously defined by the When method
func (e *FileMockReadExpectation) Then(n int, err error) *FileMock {
	e.results = &FileMockReadResults{n, err}
	return e.mock
}

// Read implements File
func (mmRead *FileMock) Read(b []byte) (n int, err error) {
	mm_atomic.AddUint64(&mmRead.beforeReadCounter, 1)
	defer mm_atomic.AddUint64(&mmRead.afterReadCounter, 1)

	if mmRead.inspectFuncRead != nil {
		mmRead.inspectFuncRead(b)
	}

	mm_params := &FileMockReadParams{b}

	// Record call args
	mmRead.ReadMock.mutex.Lock()
	mmRead.ReadMock.callArgs = append(mmRead.ReadMock.callArgs, mm_params)
	mmRead.ReadMock.mutex.Unlock()

	for _, e := range mmRead.ReadMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.n, e.results.err
		}
	}

	if mmRead.ReadMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRead.ReadMock.defaultExpectation.Counter, 1)
		mm_want := mmRead.ReadMock.defaultExpectation.params
		mm_got := FileMockReadParams{b}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRead.t.Errorf("FileMock.Read got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRead.ReadMock.defaultExpectation.results
		if mm_results == nil {
			mmRead.t.Fatal("No results are set for the FileMock.Read")
		}
		return (*mm_results).n, (*mm_results).err
	}
	if mmRead.funcRead != nil {
		return mmRead.funcRead(b)
	}
	mmRead.t.Fatalf("Unexpected call to FileMock.Read. %v", b)
	return
}

// ReadAfterCounter returns a count of finished FileMock.Read invocations
func (mmRead *FileMock) ReadAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRead.afterReadCounter)
}

// ReadBeforeCounter returns a count of FileMock.Read invocations
func (mmRead *FileMock) ReadBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRead.beforeReadCounter)
}

// Calls returns a list of arguments used in each call to FileMock.Read.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRead *mFileMockRead) Calls() []*FileMockReadParams {
	mmRead.mutex.RLock()

	argCopy := make([]*FileMockReadParams, len(mmRead.callArgs))
	copy(argCopy, mmRead.callArgs)

	mmRead.mutex.RUnlock()

	return argCopy
}

// MinimockReadDone returns true if the count of the Read invocations corresponds
// the number of defined expectations
func (m *FileMock) MinimockReadDone() bool {
	for _, e := range m.ReadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRead != nil && mm_atomic.LoadUint64(&m.afterReadCounter) < 1 {
		return false
	}
	return true
}

// MinimockReadInspect logs each unmet expectation
func (m *FileMock) MinimockReadInspect() {
	for _, e := range m.ReadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FileMock.Read with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadCounter) < 1 {
		if m.ReadMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FileMock.Read")
		} else {
			m.t.Errorf("Expected call to FileMock.Read with params: %#v", *m.ReadMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRead != nil && mm_atomic.LoadUint64(&m.afterReadCounter) < 1 {
		m.t.Error("Expected call to FileMock.Read")
	}
}

type mFileMockReadAt struct {
	mock               *FileMock
	defaultExpectation *FileMockReadAtExpectation
	expectations       []*FileMockReadAtExpectation

	callArgs []*FileMockReadAtParams
	mutex    sync.RWMutex
}

// FileMockReadAtExpectation specifies expectation struct of the File.ReadAt
type FileMockReadAtExpectation struct {
	mock    *FileMock
	params  *FileMockReadAtParams
	results *FileMockReadAtResults
	Counter uint64
}

// FileMockReadAtParams contains parameters of the File.ReadAt
type FileMockReadAtParams struct {
	b   []byte
	off int64
}

// FileMockReadAtResults contains results of the File.ReadAt
type FileMockReadAtResults struct {
	n   int
	err error
}

// Expect sets up expected params for File.ReadAt
func (mmReadAt *mFileMockReadAt) Expect(b []byte, off int64) *mFileMockReadAt {
	if mmReadAt.mock.funcReadAt != nil {
		mmReadAt.mock.t.Fatalf("FileMock.ReadAt mock is already set by Set")
	}

	if mmReadAt.defaultExpectation == nil {
		mmReadAt.defaultExpectation = &FileMockReadAtExpectation{}
	}

	mmReadAt.defaultExpectation.params = &FileMockReadAtParams{b, off}
	for _, e := range mmReadAt.expectations {
		if minimock.Equal(e.params, mmReadAt.defaultExpectation.params) {
			mmReadAt.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReadAt.defaultExpectation.params)
		}
	}

	return mmReadAt
}

// Inspect accepts an inspector function that has same arguments as the File.ReadAt
func (mmReadAt *mFileMockReadAt) Inspect(f func(b []byte, off int64)) *mFileMockReadAt {
	if mmReadAt.mock.inspectFuncReadAt != nil {
		mmReadAt.mock.t.Fatalf("Inspect function is already set for FileMock.ReadAt")
	}

	mmReadAt.mock.inspectFuncReadAt = f

	return mmReadAt
}

// Return sets up results that will be returned by File.ReadAt
func (mmReadAt *mFileMockReadAt) Return(n int, err error) *FileMock {
	if mmReadAt.mock.funcReadAt != nil {
		mmReadAt.mock.t.Fatalf("FileMock.ReadAt mock is already set by Set")
	}

	if mmReadAt.defaultExpectation == nil {
		mmReadAt.defaultExpectation = &FileMockReadAtExpectation{mock: mmReadAt.mock}
	}
	mmReadAt.defaultExpectation.results = &FileMockReadAtResults{n, err}
	return mmReadAt.mock
}

//Set uses given function f to mock the File.ReadAt method
func (mmReadAt *mFileMockReadAt) Set(f func(b []byte, off int64) (n int, err error)) *FileMock {
	if mmReadAt.defaultExpectation != nil {
		mmReadAt.mock.t.Fatalf("Default expectation is already set for the File.ReadAt method")
	}

	if len(mmReadAt.expectations) > 0 {
		mmReadAt.mock.t.Fatalf("Some expectations are already set for the File.ReadAt method")
	}

	mmReadAt.mock.funcReadAt = f
	return mmReadAt.mock
}

// When sets expectation for the File.ReadAt which will trigger the result defined by the following
// Then helper
func (mmReadAt *mFileMockReadAt) When(b []byte, off int64) *FileMockReadAtExpectation {
	if mmReadAt.mock.funcReadAt != nil {
		mmReadAt.mock.t.Fatalf("FileMock.ReadAt mock is already set by Set")
	}

	expectation := &FileMockReadAtExpectation{
		mock:   mmReadAt.mock,
		params: &FileMockReadAtParams{b, off},
	}
	mmReadAt.expectations = append(mmReadAt.expectations, expectation)
	return expectation
}

// Then sets up File.ReadAt return parameters for the expectation previously defined by the When method
func (e *FileMockReadAtExpectation) Then(n int, err error) *FileMock {
	e.results = &FileMockReadAtResults{n, err}
	return e.mock
}

// ReadAt implements File
func (mmReadAt *FileMock) ReadAt(b []byte, off int64) (n int, err error) {
	mm_atomic.AddUint64(&mmReadAt.beforeReadAtCounter, 1)
	defer mm_atomic.AddUint64(&mmReadAt.afterReadAtCounter, 1)

	if mmReadAt.inspectFuncReadAt != nil {
		mmReadAt.inspectFuncReadAt(b, off)
	}

	mm_params := &FileMockReadAtParams{b, off}

	// Record call args
	mmReadAt.ReadAtMock.mutex.Lock()
	mmReadAt.ReadAtMock.callArgs = append(mmReadAt.ReadAtMock.callArgs, mm_params)
	mmReadAt.ReadAtMock.mutex.Unlock()

	for _, e := range mmReadAt.ReadAtMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.n, e.results.err
		}
	}

	if mmReadAt.ReadAtMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReadAt.ReadAtMock.defaultExpectation.Counter, 1)
		mm_want := mmReadAt.ReadAtMock.defaultExpectation.params
		mm_got := FileMockReadAtParams{b, off}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReadAt.t.Errorf("FileMock.ReadAt got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReadAt.ReadAtMock.defaultExpectation.results
		if mm_results == nil {
			mmReadAt.t.Fatal("No results are set for the FileMock.ReadAt")
		}
		return (*mm_results).n, (*mm_results).err
	}
	if mmReadAt.funcReadAt != nil {
		return mmReadAt.funcReadAt(b, off)
	}
	mmReadAt.t.Fatalf("Unexpected call to FileMock.ReadAt. %v %v", b, off)
	return
}

// ReadAtAfterCounter returns a count of finished FileMock.ReadAt invocations
func (mmReadAt *FileMock) ReadAtAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadAt.afterReadAtCounter)
}

// ReadAtBeforeCounter returns a count of FileMock.ReadAt invocations
func (mmReadAt *FileMock) ReadAtBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadAt.beforeReadAtCounter)
}

// Calls returns a list of arguments used in each call to FileMock.ReadAt.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReadAt *mFileMockReadAt) Calls() []*FileMockReadAtParams {
	mmReadAt.mutex.RLock()

	argCopy := make([]*FileMockReadAtParams, len(mmReadAt.callArgs))
	copy(argCopy, mmReadAt.callArgs)

	mmReadAt.mutex.RUnlock()

	return argCopy
}

// MinimockReadAtDone returns true if the count of the ReadAt invocations corresponds
// the number of defined expectations
func (m *FileMock) MinimockReadAtDone() bool {
	for _, e := range m.ReadAtMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadAtMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadAtCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReadAt != nil && mm_atomic.LoadUint64(&m.afterReadAtCounter) < 1 {
		return false
	}
	return true
}

// MinimockReadAtInspect logs each unmet expectation
func (m *FileMock) MinimockReadAtInspect() {
	for _, e := range m.ReadAtMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FileMock.ReadAt with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadAtMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadAtCounter) < 1 {
		if m.ReadAtMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FileMock.ReadAt")
		} else {
			m.t.Errorf("Expected call to FileMock.ReadAt with params: %#v", *m.ReadAtMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReadAt != nil && mm_atomic.LoadUint64(&m.afterReadAtCounter) < 1 {
		m.t.Error("Expected call to FileMock.ReadAt")
	}
}

type mFileMockReaddir struct {
	mock               *FileMock
	defaultExpectation *FileMockReaddirExpectation
	expectations       []*FileMockReaddirExpectation

	callArgs []*FileMockReaddirParams
	mutex    sync.RWMutex
}

// FileMockReaddirExpectation specifies expectation struct of the File.Readdir
type FileMockReaddirExpectation struct {
	mock    *FileMock
	params  *FileMockReaddirParams
	results *FileMockReaddirResults
	Counter uint64
}

// FileMockReaddirParams contains parameters of the File.Readdir
type FileMockReaddirParams struct {
	n int
}

// FileMockReaddirResults contains results of the File.Readdir
type FileMockReaddirResults struct {
	fa1 []os.FileInfo
	err error
}

// Expect sets up expected params for File.Readdir
func (mmReaddir *mFileMockReaddir) Expect(n int) *mFileMockReaddir {
	if mmReaddir.mock.funcReaddir != nil {
		mmReaddir.mock.t.Fatalf("FileMock.Readdir mock is already set by Set")
	}

	if mmReaddir.defaultExpectation == nil {
		mmReaddir.defaultExpectation = &FileMockReaddirExpectation{}
	}

	mmReaddir.defaultExpectation.params = &FileMockReaddirParams{n}
	for _, e := range mmReaddir.expectations {
		if minimock.Equal(e.params, mmReaddir.defaultExpectation.params) {
			mmReaddir.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReaddir.defaultExpectation.params)
		}
	}

	return mmReaddir
}

// Inspect accepts an inspector function that has same arguments as the File.Readdir
func (mmReaddir *mFileMockReaddir) Inspect(f func(n int)) *mFileMockReaddir {
	if mmReaddir.mock.inspectFuncReaddir != nil {
		mmReaddir.mock.t.Fatalf("Inspect function is already set for FileMock.Readdir")
	}

	mmReaddir.mock.inspectFuncReaddir = f

	return mmReaddir
}

// Return sets up results that will be returned by File.Readdir
func (mmReaddir *mFileMockReaddir) Return(fa1 []os.FileInfo, err error) *FileMock {
	if mmReaddir.mock.funcReaddir != nil {
		mmReaddir.mock.t.Fatalf("FileMock.Readdir mock is already set by Set")
	}

	if mmReaddir.defaultExpectation == nil {
		mmReaddir.defaultExpectation = &FileMockReaddirExpectation{mock: mmReaddir.mock}
	}
	mmReaddir.defaultExpectation.results = &FileMockReaddirResults{fa1, err}
	return mmReaddir.mock
}

//Set uses given function f to mock the File.Readdir method
func (mmReaddir *mFileMockReaddir) Set(f func(n int) (fa1 []os.FileInfo, err error)) *FileMock {
	if mmReaddir.defaultExpectation != nil {
		mmReaddir.mock.t.Fatalf("Default expectation is already set for the File.Readdir method")
	}

	if len(mmReaddir.expectations) > 0 {
		mmReaddir.mock.t.Fatalf("Some expectations are already set for the File.Readdir method")
	}

	mmReaddir.mock.funcReaddir = f
	return mmReaddir.mock
}

// When sets expectation for the File.Readdir which will trigger the result defined by the following
// Then helper
func (mmReaddir *mFileMockReaddir) When(n int) *FileMockReaddirExpectation {
	if mmReaddir.mock.funcReaddir != nil {
		mmReaddir.mock.t.Fatalf("FileMock.Readdir mock is already set by Set")
	}

	expectation := &FileMockReaddirExpectation{
		mock:   mmReaddir.mock,
		params: &FileMockReaddirParams{n},
	}
	mmReaddir.expectations = append(mmReaddir.expectations, expectation)
	return expectation
}

// Then sets up File.Readdir return parameters for the expectation previously defined by the When method
func (e *FileMockReaddirExpectation) Then(fa1 []os.FileInfo, err error) *FileMock {
	e.results = &FileMockReaddirResults{fa1, err}
	return e.mock
}

// Readdir implements File
func (mmReaddir *FileMock) Readdir(n int) (fa1 []os.FileInfo, err error) {
	mm_atomic.AddUint64(&mmReaddir.beforeReaddirCounter, 1)
	defer mm_atomic.AddUint64(&mmReaddir.afterReaddirCounter, 1)

	if mmReaddir.inspectFuncReaddir != nil {
		mmReaddir.inspectFuncReaddir(n)
	}

	mm_params := &FileMockReaddirParams{n}

	// Record call args
	mmReaddir.ReaddirMock.mutex.Lock()
	mmReaddir.ReaddirMock.callArgs = append(mmReaddir.ReaddirMock.callArgs, mm_params)
	mmReaddir.ReaddirMock.mutex.Unlock()

	for _, e := range mmReaddir.ReaddirMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.fa1, e.results.err
		}
	}

	if mmReaddir.ReaddirMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReaddir.ReaddirMock.defaultExpectation.Counter, 1)
		mm_want := mmReaddir.ReaddirMock.defaultExpectation.params
		mm_got := FileMockReaddirParams{n}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReaddir.t.Errorf("FileMock.Readdir got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReaddir.ReaddirMock.defaultExpectation.results
		if mm_results == nil {
			mmReaddir.t.Fatal("No results are set for the FileMock.Readdir")
		}
		return (*mm_results).fa1, (*mm_results).err
	}
	if mmReaddir.funcReaddir != nil {
		return mmReaddir.funcReaddir(n)
	}
	mmReaddir.t.Fatalf("Unexpected call to FileMock.Readdir. %v", n)
	return
}

// ReaddirAfterCounter returns a count of finished FileMock.Readdir invocations
func (mmReaddir *FileMock) ReaddirAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReaddir.afterReaddirCounter)
}

// ReaddirBeforeCounter returns a count of FileMock.Readdir invocations
func (mmReaddir *FileMock) ReaddirBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReaddir.beforeReaddirCounter)
}

// Calls returns a list of arguments used in each call to FileMock.Readdir.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReaddir *mFileMockReaddir) Calls() []*FileMockReaddirParams {
	mmReaddir.mutex.RLock()

	argCopy := make([]*FileMockReaddirParams, len(mmReaddir.callArgs))
	copy(argCopy, mmReaddir.callArgs)

	mmReaddir.mutex.RUnlock()

	return argCopy
}

// MinimockReaddirDone returns true if the count of the Readdir invocations corresponds
// the number of defined expectations
func (m *FileMock) MinimockReaddirDone() bool {
	for _, e := range m.ReaddirMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReaddirMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReaddirCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReaddir != nil && mm_atomic.LoadUint64(&m.afterReaddirCounter) < 1 {
		return false
	}
	return true
}

// MinimockReaddirInspect logs each unmet expectation
func (m *FileMock) MinimockReaddirInspect() {
	for _, e := range m.ReaddirMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FileMock.Readdir with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReaddirMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReaddirCounter) < 1 {
		if m.ReaddirMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FileMock.Readdir")
		} else {
			m.t.Errorf("Expected call to FileMock.Readdir with params: %#v", *m.ReaddirMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReaddir != nil && mm_atomic.LoadUint64(&m.afterReaddirCounter) < 1 {
		m.t.Error("Expected call to FileMock.Readdir")
	}
}

type mFileMockReaddirnames struct {
	mock               *FileMock
	defaultExpectation *FileMockReaddirnamesExpectation
	expectations       []*FileMockReaddirnamesExpectation

	callArgs []*FileMockReaddirnamesParams
	mutex    sync.RWMutex
}

// FileMockReaddirnamesExpectation specifies expectation struct of the File.Readdirnames
type FileMockReaddirnamesExpectation struct {
	mock    *FileMock
	params  *FileMockReaddirnamesParams
	results *FileMockReaddirnamesResults
	Counter uint64
}

// FileMockReaddirnamesParams contains parameters of the File.Readdirnames
type FileMockReaddirnamesParams struct {
	n int
}

// FileMockReaddirnamesResults contains results of the File.Readdirnames
type FileMockReaddirnamesResults struct {
	names []string
	err   error
}

// Expect sets up expected params for File.Readdirnames
func (mmReaddirnames *mFileMockReaddirnames) Expect(n int) *mFileMockReaddirnames {
	if mmReaddirnames.mock.funcReaddirnames != nil {
		mmReaddirnames.mock.t.Fatalf("FileMock.Readdirnames mock is already set by Set")
	}

	if mmReaddirnames.defaultExpectation == nil {
		mmReaddirnames.defaultExpectation = &FileMockReaddirnamesExpectation{}
	}

	mmReaddirnames.defaultExpectation.params = &FileMockReaddirnamesParams{n}
	for _, e := range mmReaddirnames.expectations {
		if minimock.Equal(e.params, mmReaddirnames.defaultExpectation.params) {
			mmReaddirnames.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReaddirnames.defaultExpectation.params)
		}
	}

	return mmReaddirnames
}

// Inspect accepts an inspector function that has same arguments as the File.Readdirnames
func (mmReaddirnames *mFileMockReaddirnames) Inspect(f func(n int)) *mFileMockReaddirnames {
	if mmReaddirnames.mock.inspectFuncReaddirnames != nil {
		mmReaddirnames.mock.t.Fatalf("Inspect function is already set for FileMock.Readdirnames")
	}

	mmReaddirnames.mock.inspectFuncReaddirnames = f

	return mmReaddirnames
}

// Return sets up results that will be returned by File.Readdirnames
func (mmReaddirnames *mFileMockReaddirnames) Return(names []string, err error) *FileMock {
	if mmReaddirnames.mock.funcReaddirnames != nil {
		mmReaddirnames.mock.t.Fatalf("FileMock.Readdirnames mock is already set by Set")
	}

	if mmReaddirnames.defaultExpectation == nil {
		mmReaddirnames.defaultExpectation = &FileMockReaddirnamesExpectation{mock: mmReaddirnames.mock}
	}
	mmReaddirnames.defaultExpectation.results = &FileMockReaddirnamesResults{names, err}
	return mmReaddirnames.mock
}

//Set uses given function f to mock the File.Readdirnames method
func (mmReaddirnames *mFileMockReaddirnames) Set(f func(n int) (names []string, err error)) *FileMock {
	if mmReaddirnames.defaultExpectation != nil {
		mmReaddirnames.mock.t.Fatalf("Default expectation is already set for the File.Readdirnames method")
	}

	if len(mmReaddirnames.expectations) > 0 {
		mmReaddirnames.mock.t.Fatalf("Some expectations are already set for the File.Readdirnames method")
	}

	mmReaddirnames.mock.funcReaddirnames = f
	return mmReaddirnames.mock
}

// When sets expectation for the File.Readdirnames which will trigger the result defined by the following
// Then helper
func (mmReaddirnames *mFileMockReaddirnames) When(n int) *FileMockReaddirnamesExpectation {
	if mmReaddirnames.mock.funcReaddirnames != nil {
		mmReaddirnames.mock.t.Fatalf("FileMock.Readdirnames mock is already set by Set")
	}

	expectation := &FileMockReaddirnamesExpectation{
		mock:   mmReaddirnames.mock,
		params: &FileMockReaddirnamesParams{n},
	}
	mmReaddirnames.expectations = append(mmReaddirnames.expectations, expectation)
	return expectation
}

// Then sets up File.Readdirnames return parameters for the expectation previously defined by the When method
func (e *FileMockReaddirnamesExpectation) Then(names []string, err error) *FileMock {
	e.results = &FileMockReaddirnamesResults{names, err}
	return e.mock
}

// Readdirnames implements File
func (mmReaddirnames *FileMock) Readdirnames(n int) (names []string, err error) {
	mm_atomic.AddUint64(&mmReaddirnames.beforeReaddirnamesCounter, 1)
	defer mm_atomic.AddUint64(&mmReaddirnames.afterReaddirnamesCounter, 1)

	if mmReaddirnames.inspectFuncReaddirnames != nil {
		mmReaddirnames.inspectFuncReaddirnames(n)
	}

	mm_params := &FileMockReaddirnamesParams{n}

	// Record call args
	mmReaddirnames.ReaddirnamesMock.mutex.Lock()
	mmReaddirnames.ReaddirnamesMock.callArgs = append(mmReaddirnames.ReaddirnamesMock.callArgs, mm_params)
	mmReaddirnames.ReaddirnamesMock.mutex.Unlock()

	for _, e := range mmReaddirnames.ReaddirnamesMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.names, e.results.err
		}
	}

	if mmReaddirnames.ReaddirnamesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReaddirnames.ReaddirnamesMock.defaultExpectation.Counter, 1)
		mm_want := mmReaddirnames.ReaddirnamesMock.defaultExpectation.params
		mm_got := FileMockReaddirnamesParams{n}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReaddirnames.t.Errorf("FileMock.Readdirnames got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReaddirnames.ReaddirnamesMock.defaultExpectation.results
		if mm_results == nil {
			mmReaddirnames.t.Fatal("No results are set for the FileMock.Readdirnames")
		}
		return (*mm_results).names, (*mm_results).err
	}
	if mmReaddirnames.funcReaddirnames != nil {
		return mmReaddirnames.funcReaddirnames(n)
	}
	mmReaddirnames.t.Fatalf("Unexpected call to FileMock.Readdirnames. %v", n)
	return
}

// ReaddirnamesAfterCounter returns a count of finished FileMock.Readdirnames invocations
func (mmReaddirnames *FileMock) ReaddirnamesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReaddirnames.afterReaddirnamesCounter)
}

// ReaddirnamesBeforeCounter returns a count of FileMock.Readdirnames invocations
func (mmReaddirnames *FileMock) ReaddirnamesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReaddirnames.beforeReaddirnamesCounter)
}

// Calls returns a list of arguments used in each call to FileMock.Readdirnames.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReaddirnames *mFileMockReaddirnames) Calls() []*FileMockReaddirnamesParams {
	mmReaddirnames.mutex.RLock()

	argCopy := make([]*FileMockReaddirnamesParams, len(mmReaddirnames.callArgs))
	copy(argCopy, mmReaddirnames.callArgs)

	mmReaddirnames.mutex.RUnlock()

	return argCopy
}

// MinimockReaddirnamesDone returns true if the count of the Readdirnames invocations corresponds
// the number of defined expectations
func (m *FileMock) MinimockReaddirnamesDone() bool {
	for _, e := range m.ReaddirnamesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReaddirnamesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReaddirnamesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReaddirnames != nil && mm_atomic.LoadUint64(&m.afterReaddirnamesCounter) < 1 {
		return false
	}
	return true
}

// MinimockReaddirnamesInspect logs each unmet expectation
func (m *FileMock) MinimockReaddirnamesInspect() {
	for _, e := range m.ReaddirnamesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FileMock.Readdirnames with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReaddirnamesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReaddirnamesCounter) < 1 {
		if m.ReaddirnamesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FileMock.Readdirnames")
		} else {
			m.t.Errorf("Expected call to FileMock.Readdirnames with params: %#v", *m.ReaddirnamesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReaddirnames != nil && mm_atomic.LoadUint64(&m.afterReaddirnamesCounter) < 1 {
		m.t.Error("Expected call to FileMock.Readdirnames")
	}
}

type mFileMockSeek struct {
	mock               *FileMock
	defaultExpectation *FileMockSeekExpectation
	expectations       []*FileMockSeekExpectation

	callArgs []*FileMockSeekParams
	mutex    sync.RWMutex
}

// FileMockSeekExpectation specifies expectation struct of the File.Seek
type FileMockSeekExpectation struct {
	mock    *FileMock
	params  *FileMockSeekParams
	results *FileMockSeekResults
	Counter uint64
}

// FileMockSeekParams contains parameters of the File.Seek
type FileMockSeekParams struct {
	offset int64
	whence int
}

// FileMockSeekResults contains results of the File.Seek
type FileMockSeekResults struct {
	ret int64
	err error
}

// Expect sets up expected params for File.Seek
func (mmSeek *mFileMockSeek) Expect(offset int64, whence int) *mFileMockSeek {
	if mmSeek.mock.funcSeek != nil {
		mmSeek.mock.t.Fatalf("FileMock.Seek mock is already set by Set")
	}

	if mmSeek.defaultExpectation == nil {
		mmSeek.defaultExpectation = &FileMockSeekExpectation{}
	}

	mmSeek.defaultExpectation.params = &FileMockSeekParams{offset, whence}
	for _, e := range mmSeek.expectations {
		if minimock.Equal(e.params, mmSeek.defaultExpectation.params) {
			mmSeek.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSeek.defaultExpectation.params)
		}
	}

	return mmSeek
}

// Inspect accepts an inspector function that has same arguments as the File.Seek
func (mmSeek *mFileMockSeek) Inspect(f func(offset int64, whence int)) *mFileMockSeek {
	if mmSeek.mock.inspectFuncSeek != nil {
		mmSeek.mock.t.Fatalf("Inspect function is already set for FileMock.Seek")
	}

	mmSeek.mock.inspectFuncSeek = f

	return mmSeek
}

// Return sets up results that will be returned by File.Seek
func (mmSeek *mFileMockSeek) Return(ret int64, err error) *FileMock {
	if mmSeek.mock.funcSeek != nil {
		mmSeek.mock.t.Fatalf("FileMock.Seek mock is already set by Set")
	}

	if mmSeek.defaultExpectation == nil {
		mmSeek.defaultExpectation = &FileMockSeekExpectation{mock: mmSeek.mock}
	}
	mmSeek.defaultExpectation.results = &FileMockSeekResults{ret, err}
	return mmSeek.mock
}

//Set uses given function f to mock the File.Seek method
func (mmSeek *mFileMockSeek) Set(f func(offset int64, whence int) (ret int64, err error)) *FileMock {
	if mmSeek.defaultExpectation != nil {
		mmSeek.mock.t.Fatalf("Default expectation is already set for the File.Seek method")
	}

	if len(mmSeek.expectations) > 0 {
		mmSeek.mock.t.Fatalf("Some expectations are already set for the File.Seek method")
	}

	mmSeek.mock.funcSeek = f
	return mmSeek.mock
}

// When sets expectation for the File.Seek which will trigger the result defined by the following
// Then helper
func (mmSeek *mFileMockSeek) When(offset int64, whence int) *FileMockSeekExpectation {
	if mmSeek.mock.funcSeek != nil {
		mmSeek.mock.t.Fatalf("FileMock.Seek mock is already set by Set")
	}

	expectation := &FileMockSeekExpectation{
		mock:   mmSeek.mock,
		params: &FileMockSeekParams{offset, whence},
	}
	mmSeek.expectations = append(mmSeek.expectations, expectation)
	return expectation
}

// Then sets up File.Seek return parameters for the expectation previously defined by the When method
func (e *FileMockSeekExpectation) Then(ret int64, err error) *FileMock {
	e.results = &FileMockSeekResults{ret, err}
	return e.mock
}

// Seek implements File
func (mmSeek *FileMock) Seek(offset int64, whence int) (ret int64, err error) {
	mm_atomic.AddUint64(&mmSeek.beforeSeekCounter, 1)
	defer mm_atomic.AddUint64(&mmSeek.afterSeekCounter, 1)

	if mmSeek.inspectFuncSeek != nil {
		mmSeek.inspectFuncSeek(offset, whence)
	}

	mm_params := &FileMockSeekParams{offset, whence}

	// Record call args
	mmSeek.SeekMock.mutex.Lock()
	mmSeek.SeekMock.callArgs = append(mmSeek.SeekMock.callArgs, mm_params)
	mmSeek.SeekMock.mutex.Unlock()

	for _, e := range mmSeek.SeekMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ret, e.results.err
		}
	}

	if mmSeek.SeekMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSeek.SeekMock.defaultExpectation.Counter, 1)
		mm_want := mmSeek.SeekMock.defaultExpectation.params
		mm_got := FileMockSeekParams{offset, whence}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSeek.t.Errorf("FileMock.Seek got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSeek.SeekMock.defaultExpectation.results
		if mm_results == nil {
			mmSeek.t.Fatal("No results are set for the FileMock.Seek")
		}
		return (*mm_results).ret, (*mm_results).err
	}
	if mmSeek.funcSeek != nil {
		return mmSeek.funcSeek(offset, whence)
	}
	mmSeek.t.Fatalf("Unexpected call to FileMock.Seek. %v %v", offset, whence)
	return
}

// SeekAfterCounter returns a count of finished FileMock.Seek invocations
func (mmSeek *FileMock) SeekAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSeek.afterSeekCounter)
}

// SeekBeforeCounter returns a count of FileMock.Seek invocations
func (mmSeek *FileMock) SeekBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSeek.beforeSeekCounter)
}

// Calls returns a list of arguments used in each call to FileMock.Seek.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSeek *mFileMockSeek) Calls() []*FileMockSeekParams {
	mmSeek.mutex.RLock()

	argCopy := make([]*FileMockSeekParams, len(mmSeek.callArgs))
	copy(argCopy, mmSeek.callArgs)

	mmSeek.mutex.RUnlock()

	return argCopy
}

// MinimockSeekDone returns true if the count of the Seek invocations corresponds
// the number of defined expectations
func (m *FileMock) MinimockSeekDone() bool {
	for _, e := range m.SeekMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SeekMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSeekCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSeek != nil && mm_atomic.LoadUint64(&m.afterSeekCounter) < 1 {
		return false
	}
	return true
}

// MinimockSeekInspect logs each unmet expectation
func (m *FileMock) MinimockSeekInspect() {
	for _, e := range m.SeekMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FileMock.Seek with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SeekMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSeekCounter) < 1 {
		if m.SeekMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FileMock.Seek")
		} else {
			m.t.Errorf("Expected call to FileMock.Seek with params: %#v", *m.SeekMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSeek != nil && mm_atomic.LoadUint64(&m.afterSeekCounter) < 1 {
		m.t.Error("Expected call to FileMock.Seek")
	}
}

type mFileMockSetDeadline struct {
	mock               *FileMock
	defaultExpectation *FileMockSetDeadlineExpectation
	expectations       []*FileMockSetDeadlineExpectation

	callArgs []*FileMockSetDeadlineParams
	mutex    sync.RWMutex
}

// FileMockSetDeadlineExpectation specifies expectation struct of the File.SetDeadline
type FileMockSetDeadlineExpectation struct {
	mock    *FileMock
	params  *FileMockSetDeadlineParams
	results *FileMockSetDeadlineResults
	Counter uint64
}

// FileMockSetDeadlineParams contains parameters of the File.SetDeadline
type FileMockSetDeadlineParams struct {
	t time.Time
}

// FileMockSetDeadlineResults contains results of the File.SetDeadline
type FileMockSetDeadlineResults struct {
	err error
}

// Expect sets up expected params for File.SetDeadline
func (mmSetDeadline *mFileMockSetDeadline) Expect(t time.Time) *mFileMockSetDeadline {
	if mmSetDeadline.mock.funcSetDeadline != nil {
		mmSetDeadline.mock.t.Fatalf("FileMock.SetDeadline mock is already set by Set")
	}

	if mmSetDeadline.defaultExpectation == nil {
		mmSetDeadline.defaultExpectation = &FileMockSetDeadlineExpectation{}
	}

	mmSetDeadline.defaultExpectation.params = &FileMockSetDeadlineParams{t}
	for _, e := range mmSetDeadline.expectations {
		if minimock.Equal(e.params, mmSetDeadline.defaultExpectation.params) {
			mmSetDeadline.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetDeadline.defaultExpectation.params)
		}
	}

	return mmSetDeadline
}

// Inspect accepts an inspector function that has same arguments as the File.SetDeadline
func (mmSetDeadline *mFileMockSetDeadline) Inspect(f func(t time.Time)) *mFileMockSetDeadline {
	if mmSetDeadline.mock.inspectFuncSetDeadline != nil {
		mmSetDeadline.mock.t.Fatalf("Inspect function is already set for FileMock.SetDeadline")
	}

	mmSetDeadline.mock.inspectFuncSetDeadline = f

	return mmSetDeadline
}

// Return sets up results that will be returned by File.SetDeadline
func (mmSetDeadline *mFileMockSetDeadline) Return(err error) *FileMock {
	if mmSetDeadline.mock.funcSetDeadline != nil {
		mmSetDeadline.mock.t.Fatalf("FileMock.SetDeadline mock is already set by Set")
	}

	if mmSetDeadline.defaultExpectation == nil {
		mmSetDeadline.defaultExpectation = &FileMockSetDeadlineExpectation{mock: mmSetDeadline.mock}
	}
	mmSetDeadline.defaultExpectation.results = &FileMockSetDeadlineResults{err}
	return mmSetDeadline.mock
}

//Set uses given function f to mock the File.SetDeadline method
func (mmSetDeadline *mFileMockSetDeadline) Set(f func(t time.Time) (err error)) *FileMock {
	if mmSetDeadline.defaultExpectation != nil {
		mmSetDeadline.mock.t.Fatalf("Default expectation is already set for the File.SetDeadline method")
	}

	if len(mmSetDeadline.expectations) > 0 {
		mmSetDeadline.mock.t.Fatalf("Some expectations are already set for the File.SetDeadline method")
	}

	mmSetDeadline.mock.funcSetDeadline = f
	return mmSetDeadline.mock
}

// When sets expectation for the File.SetDeadline which will trigger the result defined by the following
// Then helper
func (mmSetDeadline *mFileMockSetDeadline) When(t time.Time) *FileMockSetDeadlineExpectation {
	if mmSetDeadline.mock.funcSetDeadline != nil {
		mmSetDeadline.mock.t.Fatalf("FileMock.SetDeadline mock is already set by Set")
	}

	expectation := &FileMockSetDeadlineExpectation{
		mock:   mmSetDeadline.mock,
		params: &FileMockSetDeadlineParams{t},
	}
	mmSetDeadline.expectations = append(mmSetDeadline.expectations, expectation)
	return expectation
}

// Then sets up File.SetDeadline return parameters for the expectation previously defined by the When method
func (e *FileMockSetDeadlineExpectation) Then(err error) *FileMock {
	e.results = &FileMockSetDeadlineResults{err}
	return e.mock
}

// SetDeadline implements File
func (mmSetDeadline *FileMock) SetDeadline(t time.Time) (err error) {
	mm_atomic.AddUint64(&mmSetDeadline.beforeSetDeadlineCounter, 1)
	defer mm_atomic.AddUint64(&mmSetDeadline.afterSetDeadlineCounter, 1)

	if mmSetDeadline.inspectFuncSetDeadline != nil {
		mmSetDeadline.inspectFuncSetDeadline(t)
	}

	mm_params := &FileMockSetDeadlineParams{t}

	// Record call args
	mmSetDeadline.SetDeadlineMock.mutex.Lock()
	mmSetDeadline.SetDeadlineMock.callArgs = append(mmSetDeadline.SetDeadlineMock.callArgs, mm_params)
	mmSetDeadline.SetDeadlineMock.mutex.Unlock()

	for _, e := range mmSetDeadline.SetDeadlineMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetDeadline.SetDeadlineMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetDeadline.SetDeadlineMock.defaultExpectation.Counter, 1)
		mm_want := mmSetDeadline.SetDeadlineMock.defaultExpectation.params
		mm_got := FileMockSetDeadlineParams{t}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetDeadline.t.Errorf("FileMock.SetDeadline got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetDeadline.SetDeadlineMock.defaultExpectation.results
		if mm_results == nil {
			mmSetDeadline.t.Fatal("No results are set for the FileMock.SetDeadline")
		}
		return (*mm_results).err
	}
	if mmSetDeadline.funcSetDeadline != nil {
		return mmSetDeadline.funcSetDeadline(t)
	}
	mmSetDeadline.t.Fatalf("Unexpected call to FileMock.SetDeadline. %v", t)
	return
}

// SetDeadlineAfterCounter returns a count of finished FileMock.SetDeadline invocations
func (mmSetDeadline *FileMock) SetDeadlineAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetDeadline.afterSetDeadlineCounter)
}

// SetDeadlineBeforeCounter returns a count of FileMock.SetDeadline invocations
func (mmSetDeadline *FileMock) SetDeadlineBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetDeadline.beforeSetDeadlineCounter)
}

// Calls returns a list of arguments used in each call to FileMock.SetDeadline.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetDeadline *mFileMockSetDeadline) Calls() []*FileMockSetDeadlineParams {
	mmSetDeadline.mutex.RLock()

	argCopy := make([]*FileMockSetDeadlineParams, len(mmSetDeadline.callArgs))
	copy(argCopy, mmSetDeadline.callArgs)

	mmSetDeadline.mutex.RUnlock()

	return argCopy
}

// MinimockSetDeadlineDone returns true if the count of the SetDeadline invocations corresponds
// the number of defined expectations
func (m *FileMock) MinimockSetDeadlineDone() bool {
	for _, e := range m.SetDeadlineMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetDeadlineMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetDeadlineCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetDeadline != nil && mm_atomic.LoadUint64(&m.afterSetDeadlineCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetDeadlineInspect logs each unmet expectation
func (m *FileMock) MinimockSetDeadlineInspect() {
	for _, e := range m.SetDeadlineMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FileMock.SetDeadline with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetDeadlineMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetDeadlineCounter) < 1 {
		if m.SetDeadlineMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FileMock.SetDeadline")
		} else {
			m.t.Errorf("Expected call to FileMock.SetDeadline with params: %#v", *m.SetDeadlineMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetDeadline != nil && mm_atomic.LoadUint64(&m.afterSetDeadlineCounter) < 1 {
		m.t.Error("Expected call to FileMock.SetDeadline")
	}
}

type mFileMockSetReadDeadline struct {
	mock               *FileMock
	defaultExpectation *FileMockSetReadDeadlineExpectation
	expectations       []*FileMockSetReadDeadlineExpectation

	callArgs []*FileMockSetReadDeadlineParams
	mutex    sync.RWMutex
}

// FileMockSetReadDeadlineExpectation specifies expectation struct of the File.SetReadDeadline
type FileMockSetReadDeadlineExpectation struct {
	mock    *FileMock
	params  *FileMockSetReadDeadlineParams
	results *FileMockSetReadDeadlineResults
	Counter uint64
}

// FileMockSetReadDeadlineParams contains parameters of the File.SetReadDeadline
type FileMockSetReadDeadlineParams struct {
	t time.Time
}

// FileMockSetReadDeadlineResults contains results of the File.SetReadDeadline
type FileMockSetReadDeadlineResults struct {
	err error
}

// Expect sets up expected params for File.SetReadDeadline
func (mmSetReadDeadline *mFileMockSetReadDeadline) Expect(t time.Time) *mFileMockSetReadDeadline {
	if mmSetReadDeadline.mock.funcSetReadDeadline != nil {
		mmSetReadDeadline.mock.t.Fatalf("FileMock.SetReadDeadline mock is already set by Set")
	}

	if mmSetReadDeadline.defaultExpectation == nil {
		mmSetReadDeadline.defaultExpectation = &FileMockSetReadDeadlineExpectation{}
	}

	mmSetReadDeadline.defaultExpectation.params = &FileMockSetReadDeadlineParams{t}
	for _, e := range mmSetReadDeadline.expectations {
		if minimock.Equal(e.params, mmSetReadDeadline.defaultExpectation.params) {
			mmSetReadDeadline.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetReadDeadline.defaultExpectation.params)
		}
	}

	return mmSetReadDeadline
}

// Inspect accepts an inspector function that has same arguments as the File.SetReadDeadline
func (mmSetReadDeadline *mFileMockSetReadDeadline) Inspect(f func(t time.Time)) *mFileMockSetReadDeadline {
	if mmSetReadDeadline.mock.inspectFuncSetReadDeadline != nil {
		mmSetReadDeadline.mock.t.Fatalf("Inspect function is already set for FileMock.SetReadDeadline")
	}

	mmSetReadDeadline.mock.inspectFuncSetReadDeadline = f

	return mmSetReadDeadline
}

// Return sets up results that will be returned by File.SetReadDeadline
func (mmSetReadDeadline *mFileMockSetReadDeadline) Return(err error) *FileMock {
	if mmSetReadDeadline.mock.funcSetReadDeadline != nil {
		mmSetReadDeadline.mock.t.Fatalf("FileMock.SetReadDeadline mock is already set by Set")
	}

	if mmSetReadDeadline.defaultExpectation == nil {
		mmSetReadDeadline.defaultExpectation = &FileMockSetReadDeadlineExpectation{mock: mmSetReadDeadline.mock}
	}
	mmSetReadDeadline.defaultExpectation.results = &FileMockSetReadDeadlineResults{err}
	return mmSetReadDeadline.mock
}

//Set uses given function f to mock the File.SetReadDeadline method
func (mmSetReadDeadline *mFileMockSetReadDeadline) Set(f func(t time.Time) (err error)) *FileMock {
	if mmSetReadDeadline.defaultExpectation != nil {
		mmSetReadDeadline.mock.t.Fatalf("Default expectation is already set for the File.SetReadDeadline method")
	}

	if len(mmSetReadDeadline.expectations) > 0 {
		mmSetReadDeadline.mock.t.Fatalf("Some expectations are already set for the File.SetReadDeadline method")
	}

	mmSetReadDeadline.mock.funcSetReadDeadline = f
	return mmSetReadDeadline.mock
}

// When sets expectation for the File.SetReadDeadline which will trigger the result defined by the following
// Then helper
func (mmSetReadDeadline *mFileMockSetReadDeadline) When(t time.Time) *FileMockSetReadDeadlineExpectation {
	if mmSetReadDeadline.mock.funcSetReadDeadline != nil {
		mmSetReadDeadline.mock.t.Fatalf("FileMock.SetReadDeadline mock is already set by Set")
	}

	expectation := &FileMockSetReadDeadlineExpectation{
		mock:   mmSetReadDeadline.mock,
		params: &FileMockSetReadDeadlineParams{t},
	}
	mmSetReadDeadline.expectations = append(mmSetReadDeadline.expectations, expectation)
	return expectation
}

// Then sets up File.SetReadDeadline return parameters for the expectation previously defined by the When method
func (e *FileMockSetReadDeadlineExpectation) Then(err error) *FileMock {
	e.results = &FileMockSetReadDeadlineResults{err}
	return e.mock
}

// SetReadDeadline implements File
func (mmSetReadDeadline *FileMock) SetReadDeadline(t time.Time) (err error) {
	mm_atomic.AddUint64(&mmSetReadDeadline.beforeSetReadDeadlineCounter, 1)
	defer mm_atomic.AddUint64(&mmSetReadDeadline.afterSetReadDeadlineCounter, 1)

	if mmSetReadDeadline.inspectFuncSetReadDeadline != nil {
		mmSetReadDeadline.inspectFuncSetReadDeadline(t)
	}

	mm_params := &FileMockSetReadDeadlineParams{t}

	// Record call args
	mmSetReadDeadline.SetReadDeadlineMock.mutex.Lock()
	mmSetReadDeadline.SetReadDeadlineMock.callArgs = append(mmSetReadDeadline.SetReadDeadlineMock.callArgs, mm_params)
	mmSetReadDeadline.SetReadDeadlineMock.mutex.Unlock()

	for _, e := range mmSetReadDeadline.SetReadDeadlineMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetReadDeadline.SetReadDeadlineMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetReadDeadline.SetReadDeadlineMock.defaultExpectation.Counter, 1)
		mm_want := mmSetReadDeadline.SetReadDeadlineMock.defaultExpectation.params
		mm_got := FileMockSetReadDeadlineParams{t}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetReadDeadline.t.Errorf("FileMock.SetReadDeadline got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetReadDeadline.SetReadDeadlineMock.defaultExpectation.results
		if mm_results == nil {
			mmSetReadDeadline.t.Fatal("No results are set for the FileMock.SetReadDeadline")
		}
		return (*mm_results).err
	}
	if mmSetReadDeadline.funcSetReadDeadline != nil {
		return mmSetReadDeadline.funcSetReadDeadline(t)
	}
	mmSetReadDeadline.t.Fatalf("Unexpected call to FileMock.SetReadDeadline. %v", t)
	return
}

// SetReadDeadlineAfterCounter returns a count of finished FileMock.SetReadDeadline invocations
func (mmSetReadDeadline *FileMock) SetReadDeadlineAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetReadDeadline.afterSetReadDeadlineCounter)
}

// SetReadDeadlineBeforeCounter returns a count of FileMock.SetReadDeadline invocations
func (mmSetReadDeadline *FileMock) SetReadDeadlineBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetReadDeadline.beforeSetReadDeadlineCounter)
}

// Calls returns a list of arguments used in each call to FileMock.SetReadDeadline.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetReadDeadline *mFileMockSetReadDeadline) Calls() []*FileMockSetReadDeadlineParams {
	mmSetReadDeadline.mutex.RLock()

	argCopy := make([]*FileMockSetReadDeadlineParams, len(mmSetReadDeadline.callArgs))
	copy(argCopy, mmSetReadDeadline.callArgs)

	mmSetReadDeadline.mutex.RUnlock()

	return argCopy
}

// MinimockSetReadDeadlineDone returns true if the count of the SetReadDeadline invocations corresponds
// the number of defined expectations
func (m *FileMock) MinimockSetReadDeadlineDone() bool {
	for _, e := range m.SetReadDeadlineMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetReadDeadlineMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetReadDeadlineCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetReadDeadline != nil && mm_atomic.LoadUint64(&m.afterSetReadDeadlineCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetReadDeadlineInspect logs each unmet expectation
func (m *FileMock) MinimockSetReadDeadlineInspect() {
	for _, e := range m.SetReadDeadlineMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FileMock.SetReadDeadline with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetReadDeadlineMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetReadDeadlineCounter) < 1 {
		if m.SetReadDeadlineMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FileMock.SetReadDeadline")
		} else {
			m.t.Errorf("Expected call to FileMock.SetReadDeadline with params: %#v", *m.SetReadDeadlineMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetReadDeadline != nil && mm_atomic.LoadUint64(&m.afterSetReadDeadlineCounter) < 1 {
		m.t.Error("Expected call to FileMock.SetReadDeadline")
	}
}

type mFileMockSetWriteDeadline struct {
	mock               *FileMock
	defaultExpectation *FileMockSetWriteDeadlineExpectation
	expectations       []*FileMockSetWriteDeadlineExpectation

	callArgs []*FileMockSetWriteDeadlineParams
	mutex    sync.RWMutex
}

// FileMockSetWriteDeadlineExpectation specifies expectation struct of the File.SetWriteDeadline
type FileMockSetWriteDeadlineExpectation struct {
	mock    *FileMock
	params  *FileMockSetWriteDeadlineParams
	results *FileMockSetWriteDeadlineResults
	Counter uint64
}

// FileMockSetWriteDeadlineParams contains parameters of the File.SetWriteDeadline
type FileMockSetWriteDeadlineParams struct {
	t time.Time
}

// FileMockSetWriteDeadlineResults contains results of the File.SetWriteDeadline
type FileMockSetWriteDeadlineResults struct {
	err error
}

// Expect sets up expected params for File.SetWriteDeadline
func (mmSetWriteDeadline *mFileMockSetWriteDeadline) Expect(t time.Time) *mFileMockSetWriteDeadline {
	if mmSetWriteDeadline.mock.funcSetWriteDeadline != nil {
		mmSetWriteDeadline.mock.t.Fatalf("FileMock.SetWriteDeadline mock is already set by Set")
	}

	if mmSetWriteDeadline.defaultExpectation == nil {
		mmSetWriteDeadline.defaultExpectation = &FileMockSetWriteDeadlineExpectation{}
	}

	mmSetWriteDeadline.defaultExpectation.params = &FileMockSetWriteDeadlineParams{t}
	for _, e := range mmSetWriteDeadline.expectations {
		if minimock.Equal(e.params, mmSetWriteDeadline.defaultExpectation.params) {
			mmSetWriteDeadline.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetWriteDeadline.defaultExpectation.params)
		}
	}

	return mmSetWriteDeadline
}

// Inspect accepts an inspector function that has same arguments as the File.SetWriteDeadline
func (mmSetWriteDeadline *mFileMockSetWriteDeadline) Inspect(f func(t time.Time)) *mFileMockSetWriteDeadline {
	if mmSetWriteDeadline.mock.inspectFuncSetWriteDeadline != nil {
		mmSetWriteDeadline.mock.t.Fatalf("Inspect function is already set for FileMock.SetWriteDeadline")
	}

	mmSetWriteDeadline.mock.inspectFuncSetWriteDeadline = f

	return mmSetWriteDeadline
}

// Return sets up results that will be returned by File.SetWriteDeadline
func (mmSetWriteDeadline *mFileMockSetWriteDeadline) Return(err error) *FileMock {
	if mmSetWriteDeadline.mock.funcSetWriteDeadline != nil {
		mmSetWriteDeadline.mock.t.Fatalf("FileMock.SetWriteDeadline mock is already set by Set")
	}

	if mmSetWriteDeadline.defaultExpectation == nil {
		mmSetWriteDeadline.defaultExpectation = &FileMockSetWriteDeadlineExpectation{mock: mmSetWriteDeadline.mock}
	}
	mmSetWriteDeadline.defaultExpectation.results = &FileMockSetWriteDeadlineResults{err}
	return mmSetWriteDeadline.mock
}

//Set uses given function f to mock the File.SetWriteDeadline method
func (mmSetWriteDeadline *mFileMockSetWriteDeadline) Set(f func(t time.Time) (err error)) *FileMock {
	if mmSetWriteDeadline.defaultExpectation != nil {
		mmSetWriteDeadline.mock.t.Fatalf("Default expectation is already set for the File.SetWriteDeadline method")
	}

	if len(mmSetWriteDeadline.expectations) > 0 {
		mmSetWriteDeadline.mock.t.Fatalf("Some expectations are already set for the File.SetWriteDeadline method")
	}

	mmSetWriteDeadline.mock.funcSetWriteDeadline = f
	return mmSetWriteDeadline.mock
}

// When sets expectation for the File.SetWriteDeadline which will trigger the result defined by the following
// Then helper
func (mmSetWriteDeadline *mFileMockSetWriteDeadline) When(t time.Time) *FileMockSetWriteDeadlineExpectation {
	if mmSetWriteDeadline.mock.funcSetWriteDeadline != nil {
		mmSetWriteDeadline.mock.t.Fatalf("FileMock.SetWriteDeadline mock is already set by Set")
	}

	expectation := &FileMockSetWriteDeadlineExpectation{
		mock:   mmSetWriteDeadline.mock,
		params: &FileMockSetWriteDeadlineParams{t},
	}
	mmSetWriteDeadline.expectations = append(mmSetWriteDeadline.expectations, expectation)
	return expectation
}

// Then sets up File.SetWriteDeadline return parameters for the expectation previously defined by the When method
func (e *FileMockSetWriteDeadlineExpectation) Then(err error) *FileMock {
	e.results = &FileMockSetWriteDeadlineResults{err}
	return e.mock
}

// SetWriteDeadline implements File
func (mmSetWriteDeadline *FileMock) SetWriteDeadline(t time.Time) (err error) {
	mm_atomic.AddUint64(&mmSetWriteDeadline.beforeSetWriteDeadlineCounter, 1)
	defer mm_atomic.AddUint64(&mmSetWriteDeadline.afterSetWriteDeadlineCounter, 1)

	if mmSetWriteDeadline.inspectFuncSetWriteDeadline != nil {
		mmSetWriteDeadline.inspectFuncSetWriteDeadline(t)
	}

	mm_params := &FileMockSetWriteDeadlineParams{t}

	// Record call args
	mmSetWriteDeadline.SetWriteDeadlineMock.mutex.Lock()
	mmSetWriteDeadline.SetWriteDeadlineMock.callArgs = append(mmSetWriteDeadline.SetWriteDeadlineMock.callArgs, mm_params)
	mmSetWriteDeadline.SetWriteDeadlineMock.mutex.Unlock()

	for _, e := range mmSetWriteDeadline.SetWriteDeadlineMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetWriteDeadline.SetWriteDeadlineMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetWriteDeadline.SetWriteDeadlineMock.defaultExpectation.Counter, 1)
		mm_want := mmSetWriteDeadline.SetWriteDeadlineMock.defaultExpectation.params
		mm_got := FileMockSetWriteDeadlineParams{t}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetWriteDeadline.t.Errorf("FileMock.SetWriteDeadline got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetWriteDeadline.SetWriteDeadlineMock.defaultExpectation.results
		if mm_results == nil {
			mmSetWriteDeadline.t.Fatal("No results are set for the FileMock.SetWriteDeadline")
		}
		return (*mm_results).err
	}
	if mmSetWriteDeadline.funcSetWriteDeadline != nil {
		return mmSetWriteDeadline.funcSetWriteDeadline(t)
	}
	mmSetWriteDeadline.t.Fatalf("Unexpected call to FileMock.SetWriteDeadline. %v", t)
	return
}

// SetWriteDeadlineAfterCounter returns a count of finished FileMock.SetWriteDeadline invocations
func (mmSetWriteDeadline *FileMock) SetWriteDeadlineAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetWriteDeadline.afterSetWriteDeadlineCounter)
}

// SetWriteDeadlineBeforeCounter returns a count of FileMock.SetWriteDeadline invocations
func (mmSetWriteDeadline *FileMock) SetWriteDeadlineBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetWriteDeadline.beforeSetWriteDeadlineCounter)
}

// Calls returns a list of arguments used in each call to FileMock.SetWriteDeadline.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetWriteDeadline *mFileMockSetWriteDeadline) Calls() []*FileMockSetWriteDeadlineParams {
	mmSetWriteDeadline.mutex.RLock()

	argCopy := make([]*FileMockSetWriteDeadlineParams, len(mmSetWriteDeadline.callArgs))
	copy(argCopy, mmSetWriteDeadline.callArgs)

	mmSetWriteDeadline.mutex.RUnlock()

	return argCopy
}

// MinimockSetWriteDeadlineDone returns true if the count of the SetWriteDeadline invocations corresponds
// the number of defined expectations
func (m *FileMock) MinimockSetWriteDeadlineDone() bool {
	for _, e := range m.SetWriteDeadlineMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetWriteDeadlineMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetWriteDeadlineCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetWriteDeadline != nil && mm_atomic.LoadUint64(&m.afterSetWriteDeadlineCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetWriteDeadlineInspect logs each unmet expectation
func (m *FileMock) MinimockSetWriteDeadlineInspect() {
	for _, e := range m.SetWriteDeadlineMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FileMock.SetWriteDeadline with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetWriteDeadlineMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetWriteDeadlineCounter) < 1 {
		if m.SetWriteDeadlineMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FileMock.SetWriteDeadline")
		} else {
			m.t.Errorf("Expected call to FileMock.SetWriteDeadline with params: %#v", *m.SetWriteDeadlineMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetWriteDeadline != nil && mm_atomic.LoadUint64(&m.afterSetWriteDeadlineCounter) < 1 {
		m.t.Error("Expected call to FileMock.SetWriteDeadline")
	}
}

type mFileMockStat struct {
	mock               *FileMock
	defaultExpectation *FileMockStatExpectation
	expectations       []*FileMockStatExpectation
}

// FileMockStatExpectation specifies expectation struct of the File.Stat
type FileMockStatExpectation struct {
	mock *FileMock

	results *FileMockStatResults
	Counter uint64
}

// FileMockStatResults contains results of the File.Stat
type FileMockStatResults struct {
	f1  os.FileInfo
	err error
}

// Expect sets up expected params for File.Stat
func (mmStat *mFileMockStat) Expect() *mFileMockStat {
	if mmStat.mock.funcStat != nil {
		mmStat.mock.t.Fatalf("FileMock.Stat mock is already set by Set")
	}

	if mmStat.defaultExpectation == nil {
		mmStat.defaultExpectation = &FileMockStatExpectation{}
	}

	return mmStat
}

// Inspect accepts an inspector function that has same arguments as the File.Stat
func (mmStat *mFileMockStat) Inspect(f func()) *mFileMockStat {
	if mmStat.mock.inspectFuncStat != nil {
		mmStat.mock.t.Fatalf("Inspect function is already set for FileMock.Stat")
	}

	mmStat.mock.inspectFuncStat = f

	return mmStat
}

// Return sets up results that will be returned by File.Stat
func (mmStat *mFileMockStat) Return(f1 os.FileInfo, err error) *FileMock {
	if mmStat.mock.funcStat != nil {
		mmStat.mock.t.Fatalf("FileMock.Stat mock is already set by Set")
	}

	if mmStat.defaultExpectation == nil {
		mmStat.defaultExpectation = &FileMockStatExpectation{mock: mmStat.mock}
	}
	mmStat.defaultExpectation.results = &FileMockStatResults{f1, err}
	return mmStat.mock
}

//Set uses given function f to mock the File.Stat method
func (mmStat *mFileMockStat) Set(f func() (f1 os.FileInfo, err error)) *FileMock {
	if mmStat.defaultExpectation != nil {
		mmStat.mock.t.Fatalf("Default expectation is already set for the File.Stat method")
	}

	if len(mmStat.expectations) > 0 {
		mmStat.mock.t.Fatalf("Some expectations are already set for the File.Stat method")
	}

	mmStat.mock.funcStat = f
	return mmStat.mock
}

// Stat implements File
func (mmStat *FileMock) Stat() (f1 os.FileInfo, err error) {
	mm_atomic.AddUint64(&mmStat.beforeStatCounter, 1)
	defer mm_atomic.AddUint64(&mmStat.afterStatCounter, 1)

	if mmStat.inspectFuncStat != nil {
		mmStat.inspectFuncStat()
	}

	if mmStat.StatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStat.StatMock.defaultExpectation.Counter, 1)

		mm_results := mmStat.StatMock.defaultExpectation.results
		if mm_results == nil {
			mmStat.t.Fatal("No results are set for the FileMock.Stat")
		}
		return (*mm_results).f1, (*mm_results).err
	}
	if mmStat.funcStat != nil {
		return mmStat.funcStat()
	}
	mmStat.t.Fatalf("Unexpected call to FileMock.Stat.")
	return
}

// StatAfterCounter returns a count of finished FileMock.Stat invocations
func (mmStat *FileMock) StatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStat.afterStatCounter)
}

// StatBeforeCounter returns a count of FileMock.Stat invocations
func (mmStat *FileMock) StatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStat.beforeStatCounter)
}

// MinimockStatDone returns true if the count of the Stat invocations corresponds
// the number of defined expectations
func (m *FileMock) MinimockStatDone() bool {
	for _, e := range m.StatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStatCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStat != nil && mm_atomic.LoadUint64(&m.afterStatCounter) < 1 {
		return false
	}
	return true
}

// MinimockStatInspect logs each unmet expectation
func (m *FileMock) MinimockStatInspect() {
	for _, e := range m.StatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to FileMock.Stat")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStatCounter) < 1 {
		m.t.Error("Expected call to FileMock.Stat")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStat != nil && mm_atomic.LoadUint64(&m.afterStatCounter) < 1 {
		m.t.Error("Expected call to FileMock.Stat")
	}
}

type mFileMockSync struct {
	mock               *FileMock
	defaultExpectation *FileMockSyncExpectation
	expectations       []*FileMockSyncExpectation
}

// FileMockSyncExpectation specifies expectation struct of the File.Sync
type FileMockSyncExpectation struct {
	mock *FileMock

	results *FileMockSyncResults
	Counter uint64
}

// FileMockSyncResults contains results of the File.Sync
type FileMockSyncResults struct {
	err error
}

// Expect sets up expected params for File.Sync
func (mmSync *mFileMockSync) Expect() *mFileMockSync {
	if mmSync.mock.funcSync != nil {
		mmSync.mock.t.Fatalf("FileMock.Sync mock is already set by Set")
	}

	if mmSync.defaultExpectation == nil {
		mmSync.defaultExpectation = &FileMockSyncExpectation{}
	}

	return mmSync
}

// Inspect accepts an inspector function that has same arguments as the File.Sync
func (mmSync *mFileMockSync) Inspect(f func()) *mFileMockSync {
	if mmSync.mock.inspectFuncSync != nil {
		mmSync.mock.t.Fatalf("Inspect function is already set for FileMock.Sync")
	}

	mmSync.mock.inspectFuncSync = f

	return mmSync
}

// Return sets up results that will be returned by File.Sync
func (mmSync *mFileMockSync) Return(err error) *FileMock {
	if mmSync.mock.funcSync != nil {
		mmSync.mock.t.Fatalf("FileMock.Sync mock is already set by Set")
	}

	if mmSync.defaultExpectation == nil {
		mmSync.defaultExpectation = &FileMockSyncExpectation{mock: mmSync.mock}
	}
	mmSync.defaultExpectation.results = &FileMockSyncResults{err}
	return mmSync.mock
}

//Set uses given function f to mock the File.Sync method
func (mmSync *mFileMockSync) Set(f func() (err error)) *FileMock {
	if mmSync.defaultExpectation != nil {
		mmSync.mock.t.Fatalf("Default expectation is already set for the File.Sync method")
	}

	if len(mmSync.expectations) > 0 {
		mmSync.mock.t.Fatalf("Some expectations are already set for the File.Sync method")
	}

	mmSync.mock.funcSync = f
	return mmSync.mock
}

// Sync implements File
func (mmSync *FileMock) Sync() (err error) {
	mm_atomic.AddUint64(&mmSync.beforeSyncCounter, 1)
	defer mm_atomic.AddUint64(&mmSync.afterSyncCounter, 1)

	if mmSync.inspectFuncSync != nil {
		mmSync.inspectFuncSync()
	}

	if mmSync.SyncMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSync.SyncMock.defaultExpectation.Counter, 1)

		mm_results := mmSync.SyncMock.defaultExpectation.results
		if mm_results == nil {
			mmSync.t.Fatal("No results are set for the FileMock.Sync")
		}
		return (*mm_results).err
	}
	if mmSync.funcSync != nil {
		return mmSync.funcSync()
	}
	mmSync.t.Fatalf("Unexpected call to FileMock.Sync.")
	return
}

// SyncAfterCounter returns a count of finished FileMock.Sync invocations
func (mmSync *FileMock) SyncAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSync.afterSyncCounter)
}

// SyncBeforeCounter returns a count of FileMock.Sync invocations
func (mmSync *FileMock) SyncBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSync.beforeSyncCounter)
}

// MinimockSyncDone returns true if the count of the Sync invocations corresponds
// the number of defined expectations
func (m *FileMock) MinimockSyncDone() bool {
	for _, e := range m.SyncMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SyncMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSyncCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSync != nil && mm_atomic.LoadUint64(&m.afterSyncCounter) < 1 {
		return false
	}
	return true
}

// MinimockSyncInspect logs each unmet expectation
func (m *FileMock) MinimockSyncInspect() {
	for _, e := range m.SyncMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to FileMock.Sync")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SyncMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSyncCounter) < 1 {
		m.t.Error("Expected call to FileMock.Sync")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSync != nil && mm_atomic.LoadUint64(&m.afterSyncCounter) < 1 {
		m.t.Error("Expected call to FileMock.Sync")
	}
}

type mFileMockTruncate struct {
	mock               *FileMock
	defaultExpectation *FileMockTruncateExpectation
	expectations       []*FileMockTruncateExpectation

	callArgs []*FileMockTruncateParams
	mutex    sync.RWMutex
}

// FileMockTruncateExpectation specifies expectation struct of the File.Truncate
type FileMockTruncateExpectation struct {
	mock    *FileMock
	params  *FileMockTruncateParams
	results *FileMockTruncateResults
	Counter uint64
}

// FileMockTruncateParams contains parameters of the File.Truncate
type FileMockTruncateParams struct {
	size int64
}

// FileMockTruncateResults contains results of the File.Truncate
type FileMockTruncateResults struct {
	err error
}

// Expect sets up expected params for File.Truncate
func (mmTruncate *mFileMockTruncate) Expect(size int64) *mFileMockTruncate {
	if mmTruncate.mock.funcTruncate != nil {
		mmTruncate.mock.t.Fatalf("FileMock.Truncate mock is already set by Set")
	}

	if mmTruncate.defaultExpectation == nil {
		mmTruncate.defaultExpectation = &FileMockTruncateExpectation{}
	}

	mmTruncate.defaultExpectation.params = &FileMockTruncateParams{size}
	for _, e := range mmTruncate.expectations {
		if minimock.Equal(e.params, mmTruncate.defaultExpectation.params) {
			mmTruncate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTruncate.defaultExpectation.params)
		}
	}

	return mmTruncate
}

// Inspect accepts an inspector function that has same arguments as the File.Truncate
func (mmTruncate *mFileMockTruncate) Inspect(f func(size int64)) *mFileMockTruncate {
	if mmTruncate.mock.inspectFuncTruncate != nil {
		mmTruncate.mock.t.Fatalf("Inspect function is already set for FileMock.Truncate")
	}

	mmTruncate.mock.inspectFuncTruncate = f

	return mmTruncate
}

// Return sets up results that will be returned by File.Truncate
func (mmTruncate *mFileMockTruncate) Return(err error) *FileMock {
	if mmTruncate.mock.funcTruncate != nil {
		mmTruncate.mock.t.Fatalf("FileMock.Truncate mock is already set by Set")
	}

	if mmTruncate.defaultExpectation == nil {
		mmTruncate.defaultExpectation = &FileMockTruncateExpectation{mock: mmTruncate.mock}
	}
	mmTruncate.defaultExpectation.results = &FileMockTruncateResults{err}
	return mmTruncate.mock
}

//Set uses given function f to mock the File.Truncate method
func (mmTruncate *mFileMockTruncate) Set(f func(size int64) (err error)) *FileMock {
	if mmTruncate.defaultExpectation != nil {
		mmTruncate.mock.t.Fatalf("Default expectation is already set for the File.Truncate method")
	}

	if len(mmTruncate.expectations) > 0 {
		mmTruncate.mock.t.Fatalf("Some expectations are already set for the File.Truncate method")
	}

	mmTruncate.mock.funcTruncate = f
	return mmTruncate.mock
}

// When sets expectation for the File.Truncate which will trigger the result defined by the following
// Then helper
func (mmTruncate *mFileMockTruncate) When(size int64) *FileMockTruncateExpectation {
	if mmTruncate.mock.funcTruncate != nil {
		mmTruncate.mock.t.Fatalf("FileMock.Truncate mock is already set by Set")
	}

	expectation := &FileMockTruncateExpectation{
		mock:   mmTruncate.mock,
		params: &FileMockTruncateParams{size},
	}
	mmTruncate.expectations = append(mmTruncate.expectations, expectation)
	return expectation
}

// Then sets up File.Truncate return parameters for the expectation previously defined by the When method
func (e *FileMockTruncateExpectation) Then(err error) *FileMock {
	e.results = &FileMockTruncateResults{err}
	return e.mock
}

// Truncate implements File
func (mmTruncate *FileMock) Truncate(size int64) (err error) {
	mm_atomic.AddUint64(&mmTruncate.beforeTruncateCounter, 1)
	defer mm_atomic.AddUint64(&mmTruncate.afterTruncateCounter, 1)

	if mmTruncate.inspectFuncTruncate != nil {
		mmTruncate.inspectFuncTruncate(size)
	}

	mm_params := &FileMockTruncateParams{size}

	// Record call args
	mmTruncate.TruncateMock.mutex.Lock()
	mmTruncate.TruncateMock.callArgs = append(mmTruncate.TruncateMock.callArgs, mm_params)
	mmTruncate.TruncateMock.mutex.Unlock()

	for _, e := range mmTruncate.TruncateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmTruncate.TruncateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTruncate.TruncateMock.defaultExpectation.Counter, 1)
		mm_want := mmTruncate.TruncateMock.defaultExpectation.params
		mm_got := FileMockTruncateParams{size}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTruncate.t.Errorf("FileMock.Truncate got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmTruncate.TruncateMock.defaultExpectation.results
		if mm_results == nil {
			mmTruncate.t.Fatal("No results are set for the FileMock.Truncate")
		}
		return (*mm_results).err
	}
	if mmTruncate.funcTruncate != nil {
		return mmTruncate.funcTruncate(size)
	}
	mmTruncate.t.Fatalf("Unexpected call to FileMock.Truncate. %v", size)
	return
}

// TruncateAfterCounter returns a count of finished FileMock.Truncate invocations
func (mmTruncate *FileMock) TruncateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTruncate.afterTruncateCounter)
}

// TruncateBeforeCounter returns a count of FileMock.Truncate invocations
func (mmTruncate *FileMock) TruncateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTruncate.beforeTruncateCounter)
}

// Calls returns a list of arguments used in each call to FileMock.Truncate.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTruncate *mFileMockTruncate) Calls() []*FileMockTruncateParams {
	mmTruncate.mutex.RLock()

	argCopy := make([]*FileMockTruncateParams, len(mmTruncate.callArgs))
	copy(argCopy, mmTruncate.callArgs)

	mmTruncate.mutex.RUnlock()

	return argCopy
}

// MinimockTruncateDone returns true if the count of the Truncate invocations corresponds
// the number of defined expectations
func (m *FileMock) MinimockTruncateDone() bool {
	for _, e := range m.TruncateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TruncateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTruncateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTruncate != nil && mm_atomic.LoadUint64(&m.afterTruncateCounter) < 1 {
		return false
	}
	return true
}

// MinimockTruncateInspect logs each unmet expectation
func (m *FileMock) MinimockTruncateInspect() {
	for _, e := range m.TruncateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FileMock.Truncate with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TruncateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTruncateCounter) < 1 {
		if m.TruncateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FileMock.Truncate")
		} else {
			m.t.Errorf("Expected call to FileMock.Truncate with params: %#v", *m.TruncateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTruncate != nil && mm_atomic.LoadUint64(&m.afterTruncateCounter) < 1 {
		m.t.Error("Expected call to FileMock.Truncate")
	}
}

type mFileMockWrite struct {
	mock               *FileMock
	defaultExpectation *FileMockWriteExpectation
	expectations       []*FileMockWriteExpectation

	callArgs []*FileMockWriteParams
	mutex    sync.RWMutex
}

// FileMockWriteExpectation specifies expectation struct of the File.Write
type FileMockWriteExpectation struct {
	mock    *FileMock
	params  *FileMockWriteParams
	results *FileMockWriteResults
	Counter uint64
}

// FileMockWriteParams contains parameters of the File.Write
type FileMockWriteParams struct {
	b []byte
}

// FileMockWriteResults contains results of the File.Write
type FileMockWriteResults struct {
	n   int
	err error
}

// Expect sets up expected params for File.Write
func (mmWrite *mFileMockWrite) Expect(b []byte) *mFileMockWrite {
	if mmWrite.mock.funcWrite != nil {
		mmWrite.mock.t.Fatalf("FileMock.Write mock is already set by Set")
	}

	if mmWrite.defaultExpectation == nil {
		mmWrite.defaultExpectation = &FileMockWriteExpectation{}
	}

	mmWrite.defaultExpectation.params = &FileMockWriteParams{b}
	for _, e := range mmWrite.expectations {
		if minimock.Equal(e.params, mmWrite.defaultExpectation.params) {
			mmWrite.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWrite.defaultExpectation.params)
		}
	}

	return mmWrite
}

// Inspect accepts an inspector function that has same arguments as the File.Write
func (mmWrite *mFileMockWrite) Inspect(f func(b []byte)) *mFileMockWrite {
	if mmWrite.mock.inspectFuncWrite != nil {
		mmWrite.mock.t.Fatalf("Inspect function is already set for FileMock.Write")
	}

	mmWrite.mock.inspectFuncWrite = f

	return mmWrite
}

// Return sets up results that will be returned by File.Write
func (mmWrite *mFileMockWrite) Return(n int, err error) *FileMock {
	if mmWrite.mock.funcWrite != nil {
		mmWrite.mock.t.Fatalf("FileMock.Write mock is already set by Set")
	}

	if mmWrite.defaultExpectation == nil {
		mmWrite.defaultExpectation = &FileMockWriteExpectation{mock: mmWrite.mock}
	}
	mmWrite.defaultExpectation.results = &FileMockWriteResults{n, err}
	return mmWrite.mock
}

//Set uses given function f to mock the File.Write method
func (mmWrite *mFileMockWrite) Set(f func(b []byte) (n int, err error)) *FileMock {
	if mmWrite.defaultExpectation != nil {
		mmWrite.mock.t.Fatalf("Default expectation is already set for the File.Write method")
	}

	if len(mmWrite.expectations) > 0 {
		mmWrite.mock.t.Fatalf("Some expectations are already set for the File.Write method")
	}

	mmWrite.mock.funcWrite = f
	return mmWrite.mock
}

// When sets expectation for the File.Write which will trigger the result defined by the following
// Then helper
func (mmWrite *mFileMockWrite) When(b []byte) *FileMockWriteExpectation {
	if mmWrite.mock.funcWrite != nil {
		mmWrite.mock.t.Fatalf("FileMock.Write mock is already set by Set")
	}

	expectation := &FileMockWriteExpectation{
		mock:   mmWrite.mock,
		params: &FileMockWriteParams{b},
	}
	mmWrite.expectations = append(mmWrite.expectations, expectation)
	return expectation
}

// Then sets up File.Write return parameters for the expectation previously defined by the When method
func (e *FileMockWriteExpectation) Then(n int, err error) *FileMock {
	e.results = &FileMockWriteResults{n, err}
	return e.mock
}

// Write implements File
func (mmWrite *FileMock) Write(b []byte) (n int, err error) {
	mm_atomic.AddUint64(&mmWrite.beforeWriteCounter, 1)
	defer mm_atomic.AddUint64(&mmWrite.afterWriteCounter, 1)

	if mmWrite.inspectFuncWrite != nil {
		mmWrite.inspectFuncWrite(b)
	}

	mm_params := &FileMockWriteParams{b}

	// Record call args
	mmWrite.WriteMock.mutex.Lock()
	mmWrite.WriteMock.callArgs = append(mmWrite.WriteMock.callArgs, mm_params)
	mmWrite.WriteMock.mutex.Unlock()

	for _, e := range mmWrite.WriteMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.n, e.results.err
		}
	}

	if mmWrite.WriteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWrite.WriteMock.defaultExpectation.Counter, 1)
		mm_want := mmWrite.WriteMock.defaultExpectation.params
		mm_got := FileMockWriteParams{b}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWrite.t.Errorf("FileMock.Write got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWrite.WriteMock.defaultExpectation.results
		if mm_results == nil {
			mmWrite.t.Fatal("No results are set for the FileMock.Write")
		}
		return (*mm_results).n, (*mm_results).err
	}
	if mmWrite.funcWrite != nil {
		return mmWrite.funcWrite(b)
	}
	mmWrite.t.Fatalf("Unexpected call to FileMock.Write. %v", b)
	return
}

// WriteAfterCounter returns a count of finished FileMock.Write invocations
func (mmWrite *FileMock) WriteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWrite.afterWriteCounter)
}

// WriteBeforeCounter returns a count of FileMock.Write invocations
func (mmWrite *FileMock) WriteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWrite.beforeWriteCounter)
}

// Calls returns a list of arguments used in each call to FileMock.Write.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWrite *mFileMockWrite) Calls() []*FileMockWriteParams {
	mmWrite.mutex.RLock()

	argCopy := make([]*FileMockWriteParams, len(mmWrite.callArgs))
	copy(argCopy, mmWrite.callArgs)

	mmWrite.mutex.RUnlock()

	return argCopy
}

// MinimockWriteDone returns true if the count of the Write invocations corresponds
// the number of defined expectations
func (m *FileMock) MinimockWriteDone() bool {
	for _, e := range m.WriteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WriteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWriteCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWrite != nil && mm_atomic.LoadUint64(&m.afterWriteCounter) < 1 {
		return false
	}
	return true
}

// MinimockWriteInspect logs each unmet expectation
func (m *FileMock) MinimockWriteInspect() {
	for _, e := range m.WriteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FileMock.Write with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WriteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWriteCounter) < 1 {
		if m.WriteMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FileMock.Write")
		} else {
			m.t.Errorf("Expected call to FileMock.Write with params: %#v", *m.WriteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWrite != nil && mm_atomic.LoadUint64(&m.afterWriteCounter) < 1 {
		m.t.Error("Expected call to FileMock.Write")
	}
}

type mFileMockWriteAt struct {
	mock               *FileMock
	defaultExpectation *FileMockWriteAtExpectation
	expectations       []*FileMockWriteAtExpectation

	callArgs []*FileMockWriteAtParams
	mutex    sync.RWMutex
}

// FileMockWriteAtExpectation specifies expectation struct of the File.WriteAt
type FileMockWriteAtExpectation struct {
	mock    *FileMock
	params  *FileMockWriteAtParams
	results *FileMockWriteAtResults
	Counter uint64
}

// FileMockWriteAtParams contains parameters of the File.WriteAt
type FileMockWriteAtParams struct {
	b   []byte
	off int64
}

// FileMockWriteAtResults contains results of the File.WriteAt
type FileMockWriteAtResults struct {
	n   int
	err error
}

// Expect sets up expected params for File.WriteAt
func (mmWriteAt *mFileMockWriteAt) Expect(b []byte, off int64) *mFileMockWriteAt {
	if mmWriteAt.mock.funcWriteAt != nil {
		mmWriteAt.mock.t.Fatalf("FileMock.WriteAt mock is already set by Set")
	}

	if mmWriteAt.defaultExpectation == nil {
		mmWriteAt.defaultExpectation = &FileMockWriteAtExpectation{}
	}

	mmWriteAt.defaultExpectation.params = &FileMockWriteAtParams{b, off}
	for _, e := range mmWriteAt.expectations {
		if minimock.Equal(e.params, mmWriteAt.defaultExpectation.params) {
			mmWriteAt.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWriteAt.defaultExpectation.params)
		}
	}

	return mmWriteAt
}

// Inspect accepts an inspector function that has same arguments as the File.WriteAt
func (mmWriteAt *mFileMockWriteAt) Inspect(f func(b []byte, off int64)) *mFileMockWriteAt {
	if mmWriteAt.mock.inspectFuncWriteAt != nil {
		mmWriteAt.mock.t.Fatalf("Inspect function is already set for FileMock.WriteAt")
	}

	mmWriteAt.mock.inspectFuncWriteAt = f

	return mmWriteAt
}

// Return sets up results that will be returned by File.WriteAt
func (mmWriteAt *mFileMockWriteAt) Return(n int, err error) *FileMock {
	if mmWriteAt.mock.funcWriteAt != nil {
		mmWriteAt.mock.t.Fatalf("FileMock.WriteAt mock is already set by Set")
	}

	if mmWriteAt.defaultExpectation == nil {
		mmWriteAt.defaultExpectation = &FileMockWriteAtExpectation{mock: mmWriteAt.mock}
	}
	mmWriteAt.defaultExpectation.results = &FileMockWriteAtResults{n, err}
	return mmWriteAt.mock
}

//Set uses given function f to mock the File.WriteAt method
func (mmWriteAt *mFileMockWriteAt) Set(f func(b []byte, off int64) (n int, err error)) *FileMock {
	if mmWriteAt.defaultExpectation != nil {
		mmWriteAt.mock.t.Fatalf("Default expectation is already set for the File.WriteAt method")
	}

	if len(mmWriteAt.expectations) > 0 {
		mmWriteAt.mock.t.Fatalf("Some expectations are already set for the File.WriteAt method")
	}

	mmWriteAt.mock.funcWriteAt = f
	return mmWriteAt.mock
}

// When sets expectation for the File.WriteAt which will trigger the result defined by the following
// Then helper
func (mmWriteAt *mFileMockWriteAt) When(b []byte, off int64) *FileMockWriteAtExpectation {
	if mmWriteAt.mock.funcWriteAt != nil {
		mmWriteAt.mock.t.Fatalf("FileMock.WriteAt mock is already set by Set")
	}

	expectation := &FileMockWriteAtExpectation{
		mock:   mmWriteAt.mock,
		params: &FileMockWriteAtParams{b, off},
	}
	mmWriteAt.expectations = append(mmWriteAt.expectations, expectation)
	return expectation
}

// Then sets up File.WriteAt return parameters for the expectation previously defined by the When method
func (e *FileMockWriteAtExpectation) Then(n int, err error) *FileMock {
	e.results = &FileMockWriteAtResults{n, err}
	return e.mock
}

// WriteAt implements File
func (mmWriteAt *FileMock) WriteAt(b []byte, off int64) (n int, err error) {
	mm_atomic.AddUint64(&mmWriteAt.beforeWriteAtCounter, 1)
	defer mm_atomic.AddUint64(&mmWriteAt.afterWriteAtCounter, 1)

	if mmWriteAt.inspectFuncWriteAt != nil {
		mmWriteAt.inspectFuncWriteAt(b, off)
	}

	mm_params := &FileMockWriteAtParams{b, off}

	// Record call args
	mmWriteAt.WriteAtMock.mutex.Lock()
	mmWriteAt.WriteAtMock.callArgs = append(mmWriteAt.WriteAtMock.callArgs, mm_params)
	mmWriteAt.WriteAtMock.mutex.Unlock()

	for _, e := range mmWriteAt.WriteAtMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.n, e.results.err
		}
	}

	if mmWriteAt.WriteAtMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWriteAt.WriteAtMock.defaultExpectation.Counter, 1)
		mm_want := mmWriteAt.WriteAtMock.defaultExpectation.params
		mm_got := FileMockWriteAtParams{b, off}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWriteAt.t.Errorf("FileMock.WriteAt got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWriteAt.WriteAtMock.defaultExpectation.results
		if mm_results == nil {
			mmWriteAt.t.Fatal("No results are set for the FileMock.WriteAt")
		}
		return (*mm_results).n, (*mm_results).err
	}
	if mmWriteAt.funcWriteAt != nil {
		return mmWriteAt.funcWriteAt(b, off)
	}
	mmWriteAt.t.Fatalf("Unexpected call to FileMock.WriteAt. %v %v", b, off)
	return
}

// WriteAtAfterCounter returns a count of finished FileMock.WriteAt invocations
func (mmWriteAt *FileMock) WriteAtAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWriteAt.afterWriteAtCounter)
}

// WriteAtBeforeCounter returns a count of FileMock.WriteAt invocations
func (mmWriteAt *FileMock) WriteAtBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWriteAt.beforeWriteAtCounter)
}

// Calls returns a list of arguments used in each call to FileMock.WriteAt.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWriteAt *mFileMockWriteAt) Calls() []*FileMockWriteAtParams {
	mmWriteAt.mutex.RLock()

	argCopy := make([]*FileMockWriteAtParams, len(mmWriteAt.callArgs))
	copy(argCopy, mmWriteAt.callArgs)

	mmWriteAt.mutex.RUnlock()

	return argCopy
}

// MinimockWriteAtDone returns true if the count of the WriteAt invocations corresponds
// the number of defined expectations
func (m *FileMock) MinimockWriteAtDone() bool {
	for _, e := range m.WriteAtMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WriteAtMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWriteAtCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWriteAt != nil && mm_atomic.LoadUint64(&m.afterWriteAtCounter) < 1 {
		return false
	}
	return true
}

// MinimockWriteAtInspect logs each unmet expectation
func (m *FileMock) MinimockWriteAtInspect() {
	for _, e := range m.WriteAtMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FileMock.WriteAt with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WriteAtMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWriteAtCounter) < 1 {
		if m.WriteAtMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FileMock.WriteAt")
		} else {
			m.t.Errorf("Expected call to FileMock.WriteAt with params: %#v", *m.WriteAtMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWriteAt != nil && mm_atomic.LoadUint64(&m.afterWriteAtCounter) < 1 {
		m.t.Error("Expected call to FileMock.WriteAt")
	}
}

type mFileMockWriteString struct {
	mock               *FileMock
	defaultExpectation *FileMockWriteStringExpectation
	expectations       []*FileMockWriteStringExpectation

	callArgs []*FileMockWriteStringParams
	mutex    sync.RWMutex
}

// FileMockWriteStringExpectation specifies expectation struct of the File.WriteString
type FileMockWriteStringExpectation struct {
	mock    *FileMock
	params  *FileMockWriteStringParams
	results *FileMockWriteStringResults
	Counter uint64
}

// FileMockWriteStringParams contains parameters of the File.WriteString
type FileMockWriteStringParams struct {
	s string
}

// FileMockWriteStringResults contains results of the File.WriteString
type FileMockWriteStringResults struct {
	n   int
	err error
}

// Expect sets up expected params for File.WriteString
func (mmWriteString *mFileMockWriteString) Expect(s string) *mFileMockWriteString {
	if mmWriteString.mock.funcWriteString != nil {
		mmWriteString.mock.t.Fatalf("FileMock.WriteString mock is already set by Set")
	}

	if mmWriteString.defaultExpectation == nil {
		mmWriteString.defaultExpectation = &FileMockWriteStringExpectation{}
	}

	mmWriteString.defaultExpectation.params = &FileMockWriteStringParams{s}
	for _, e := range mmWriteString.expectations {
		if minimock.Equal(e.params, mmWriteString.defaultExpectation.params) {
			mmWriteString.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWriteString.defaultExpectation.params)
		}
	}

	return mmWriteString
}

// Inspect accepts an inspector function that has same arguments as the File.WriteString
func (mmWriteString *mFileMockWriteString) Inspect(f func(s string)) *mFileMockWriteString {
	if mmWriteString.mock.inspectFuncWriteString != nil {
		mmWriteString.mock.t.Fatalf("Inspect function is already set for FileMock.WriteString")
	}

	mmWriteString.mock.inspectFuncWriteString = f

	return mmWriteString
}

// Return sets up results that will be returned by File.WriteString
func (mmWriteString *mFileMockWriteString) Return(n int, err error) *FileMock {
	if mmWriteString.mock.funcWriteString != nil {
		mmWriteString.mock.t.Fatalf("FileMock.WriteString mock is already set by Set")
	}

	if mmWriteString.defaultExpectation == nil {
		mmWriteString.defaultExpectation = &FileMockWriteStringExpectation{mock: mmWriteString.mock}
	}
	mmWriteString.defaultExpectation.results = &FileMockWriteStringResults{n, err}
	return mmWriteString.mock
}

//Set uses given function f to mock the File.WriteString method
func (mmWriteString *mFileMockWriteString) Set(f func(s string) (n int, err error)) *FileMock {
	if mmWriteString.defaultExpectation != nil {
		mmWriteString.mock.t.Fatalf("Default expectation is already set for the File.WriteString method")
	}

	if len(mmWriteString.expectations) > 0 {
		mmWriteString.mock.t.Fatalf("Some expectations are already set for the File.WriteString method")
	}

	mmWriteString.mock.funcWriteString = f
	return mmWriteString.mock
}

// When sets expectation for the File.WriteString which will trigger the result defined by the following
// Then helper
func (mmWriteString *mFileMockWriteString) When(s string) *FileMockWriteStringExpectation {
	if mmWriteString.mock.funcWriteString != nil {
		mmWriteString.mock.t.Fatalf("FileMock.WriteString mock is already set by Set")
	}

	expectation := &FileMockWriteStringExpectation{
		mock:   mmWriteString.mock,
		params: &FileMockWriteStringParams{s},
	}
	mmWriteString.expectations = append(mmWriteString.expectations, expectation)
	return expectation
}

// Then sets up File.WriteString return parameters for the expectation previously defined by the When method
func (e *FileMockWriteStringExpectation) Then(n int, err error) *FileMock {
	e.results = &FileMockWriteStringResults{n, err}
	return e.mock
}

// WriteString implements File
func (mmWriteString *FileMock) WriteString(s string) (n int, err error) {
	mm_atomic.AddUint64(&mmWriteString.beforeWriteStringCounter, 1)
	defer mm_atomic.AddUint64(&mmWriteString.afterWriteStringCounter, 1)

	if mmWriteString.inspectFuncWriteString != nil {
		mmWriteString.inspectFuncWriteString(s)
	}

	mm_params := &FileMockWriteStringParams{s}

	// Record call args
	mmWriteString.WriteStringMock.mutex.Lock()
	mmWriteString.WriteStringMock.callArgs = append(mmWriteString.WriteStringMock.callArgs, mm_params)
	mmWriteString.WriteStringMock.mutex.Unlock()

	for _, e := range mmWriteString.WriteStringMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.n, e.results.err
		}
	}

	if mmWriteString.WriteStringMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWriteString.WriteStringMock.defaultExpectation.Counter, 1)
		mm_want := mmWriteString.WriteStringMock.defaultExpectation.params
		mm_got := FileMockWriteStringParams{s}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWriteString.t.Errorf("FileMock.WriteString got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWriteString.WriteStringMock.defaultExpectation.results
		if mm_results == nil {
			mmWriteString.t.Fatal("No results are set for the FileMock.WriteString")
		}
		return (*mm_results).n, (*mm_results).err
	}
	if mmWriteString.funcWriteString != nil {
		return mmWriteString.funcWriteString(s)
	}
	mmWriteString.t.Fatalf("Unexpected call to FileMock.WriteString. %v", s)
	return
}

// WriteStringAfterCounter returns a count of finished FileMock.WriteString invocations
func (mmWriteString *FileMock) WriteStringAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWriteString.afterWriteStringCounter)
}

// WriteStringBeforeCounter returns a count of FileMock.WriteString invocations
func (mmWriteString *FileMock) WriteStringBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWriteString.beforeWriteStringCounter)
}

// Calls returns a list of arguments used in each call to FileMock.WriteString.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWriteString *mFileMockWriteString) Calls() []*FileMockWriteStringParams {
	mmWriteString.mutex.RLock()

	argCopy := make([]*FileMockWriteStringParams, len(mmWriteString.callArgs))
	copy(argCopy, mmWriteString.callArgs)

	mmWriteString.mutex.RUnlock()

	return argCopy
}

// MinimockWriteStringDone returns true if the count of the WriteString invocations corresponds
// the number of defined expectations
func (m *FileMock) MinimockWriteStringDone() bool {
	for _, e := range m.WriteStringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WriteStringMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWriteStringCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWriteString != nil && mm_atomic.LoadUint64(&m.afterWriteStringCounter) < 1 {
		return false
	}
	return true
}

// MinimockWriteStringInspect logs each unmet expectation
func (m *FileMock) MinimockWriteStringInspect() {
	for _, e := range m.WriteStringMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FileMock.WriteString with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WriteStringMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWriteStringCounter) < 1 {
		if m.WriteStringMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FileMock.WriteString")
		} else {
			m.t.Errorf("Expected call to FileMock.WriteString with params: %#v", *m.WriteStringMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWriteString != nil && mm_atomic.LoadUint64(&m.afterWriteStringCounter) < 1 {
		m.t.Error("Expected call to FileMock.WriteString")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *FileMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockChdirInspect()

		m.MinimockChmodInspect()

		m.MinimockChownInspect()

		m.MinimockCloseInspect()

		m.MinimockFdInspect()

		m.MinimockNameInspect()

		m.MinimockReadInspect()

		m.MinimockReadAtInspect()

		m.MinimockReaddirInspect()

		m.MinimockReaddirnamesInspect()

		m.MinimockSeekInspect()

		m.MinimockSetDeadlineInspect()

		m.MinimockSetReadDeadlineInspect()

		m.MinimockSetWriteDeadlineInspect()

		m.MinimockStatInspect()

		m.MinimockSyncInspect()

		m.MinimockTruncateInspect()

		m.MinimockWriteInspect()

		m.MinimockWriteAtInspect()

		m.MinimockWriteStringInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *FileMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *FileMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockChdirDone() &&
		m.MinimockChmodDone() &&
		m.MinimockChownDone() &&
		m.MinimockCloseDone() &&
		m.MinimockFdDone() &&
		m.MinimockNameDone() &&
		m.MinimockReadDone() &&
		m.MinimockReadAtDone() &&
		m.MinimockReaddirDone() &&
		m.MinimockReaddirnamesDone() &&
		m.MinimockSeekDone() &&
		m.MinimockSetDeadlineDone() &&
		m.MinimockSetReadDeadlineDone() &&
		m.MinimockSetWriteDeadlineDone() &&
		m.MinimockStatDone() &&
		m.MinimockSyncDone() &&
		m.MinimockTruncateDone() &&
		m.MinimockWriteDone() &&
		m.MinimockWriteAtDone() &&
		m.MinimockWriteStringDone()
}
